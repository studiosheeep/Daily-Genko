<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>åŸç¨¿ãƒãƒƒãƒ—</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- favicon 404 å¯¾ç­–ï¼ˆå°ã•ãªç·‘ä¸¸ã‚¢ã‚¤ã‚³ãƒ³ï¼‰ -->
  <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' fill='%2322c55e'/%3E%3C/svg%3E">

  <style>
    /* ===== å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆãƒ€ãƒ¼ã‚¯ï¼‹ãƒ•ãƒ©ãƒƒãƒˆåŸºèª¿ï¼‰ ===== */
    :root {
      color-scheme: dark;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #020617;
      color: #e5e7eb;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 4px;
      color: #f9fafb;
    }
    .app-container {
      max-width: 960px;
      margin: 0 auto;
      background: radial-gradient(circle at top left, #1f2937 0, #020617 55%);
      border-radius: 24px;
      box-shadow:
        0 24px 60px rgba(0,0,0,0.55),
        0 0 0 1px rgba(15,23,42,0.9);
      padding: 18px 16px 20px;
    }

.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;

  margin-bottom: 16px;
  padding: 10px 16px;

  background: linear-gradient(135deg, #22c55e, #16a34a);
  border-radius: 20px;
  box-shadow:
    0 14px 30px rgba(0, 0, 0, 0.45),
    0 0 0 1px rgba(21, 128, 61, 0.6);
  color: #fff;
}

.top-bar-left {
  flex: 1 1 auto;
  min-width: 180px;
}

/* ãƒ¡ã‚¤ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆæ¬¡ã«ã‚„ã‚‹ã“ã¨ï¼‰ */
.top-bar-left h1#nextTaskTitle {
  font-size: 18px;
  font-weight: 800;
  margin: 0 0 2px;
  color: #fff;
}

/* å°ã•ã‚ã®è£œè¶³è¡Œï¼ˆã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«çš„ã«ï¼‰ */
.top-bar-info {
  font-size: 12px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
}

/* å³å´ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆé€£ç¶šæ—¥æ•°ï¼‹ãƒœã‚¿ãƒ³ï¼‰ */
.top-bar-right {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 10px;
  flex: 0 0 auto;
}

/* 600px ä»¥ä¸‹ã§ç¸¦ä¸¦ã³ã«ã—ã¦ä¸­å¤®å¯„ã› */
@media (max-width: 600px) {
  .top-bar {
    flex-direction: column;
    align-items: stretch;
  }
  .top-bar-right {
    justify-content: flex-end;
    align-self: stretch;
  }
}
    
.streak-box {
  border-radius: 14px;
  padding: 6px 10px;
  font-size: 10px;
  background: rgba(0, 0, 0, 0.15);
  border: 1px solid rgba(255, 255, 255, 0.3);
  text-align: right;
  box-shadow: none;
}

.streak-label {
  color: rgba(255, 255, 255, 0.85);
  margin-bottom: 1px;
}

.streak-value {
  font-size: 16px;
  font-weight: 800;
  color: #fef9c3;
}

.streak-note {
  color: rgba(255, 255, 255, 0.8);
  font-size: 9px;
  margin-top: 2px;
}

/* ã‚¬ã‚¤ãƒ‰ãƒ–ãƒƒã‚¯é¢¨ãƒœã‚¿ãƒ³ */
.reset-btn {
  border-radius: 999px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  background: rgba(255, 255, 255, 0.12);
  color: #ffffff;
  padding: 6px 14px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 3px 0 rgba(22, 101, 52, 0.7);
}

.reset-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.reset-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(22, 101, 52, 0.7);
}
    /* ===== ãƒšãƒ¼ã‚¸ãƒŠãƒ“ï¼ˆãƒ•ãƒ©ãƒƒãƒˆãƒœã‚¿ãƒ³é¢¨ï¼‰ ===== */
    .page-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      color: #e5e7eb;
    }
    .page-nav button {
      border: 1px solid #1f2937;
      background: #020617;
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 12px;
      cursor: pointer;
      color: #e5e7eb;
      box-shadow: 0 2px 0 rgba(15,23,42,0.9);
    }
    .page-nav button:hover:not(:disabled) {
      background: #111827;
    }
    .page-nav button:active:not(:disabled) {
      transform: translateY(1px);
      box-shadow: 0 1px 0 rgba(15,23,42,0.9);
    }
    .page-nav button:disabled {
      opacity: 0.35;
      cursor: default;
      box-shadow: none;
    }
    .page-nav-label {
      min-width: 150px;
      text-align: center;
      font-weight: 500;
      color: #e5e7eb;
    }

/* ãƒšãƒ¼ã‚¸å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆã‚´ãƒŸç®±é¢¨ï¼‰ */
.page-reset-btn {
  border: 1px solid #881337;
  background: #450a0a;
  color: #fecaca;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 12px;
  cursor: pointer;
  box-shadow: 0 2px 0 rgba(15,23,42,0.6);
}

.page-reset-btn:hover {
  background: #7f1d1d;
}

.page-reset-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(15,23,42,0.6);
}    
    
    /* ===== ãƒãƒƒãƒ—ã‚¨ãƒªã‚¢ï¼ˆDuolingo é¢¨ï¼‰ ===== */
    .board-wrapper {
      margin-bottom: 4px;
      position: relative;
    }
    .map {
      position: relative;
      width: 100%;
      padding-bottom: 160%; /* PC åŸºæº– */
      border-radius: 20px;
      background:
        radial-gradient(circle at 20% 0%, rgba(56,189,248,0.12) 0, transparent 55%),
        radial-gradient(circle at 80% 90%, rgba(34,197,94,0.16) 0, transparent 55%),
        #020617;
      box-shadow:
        inset 0 0 0 1px rgba(15,23,42,0.8),
        0 18px 40px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    /* ã‚¹ãƒãƒ›æ™‚ã¯ç¸¦é•·ã« */
    @media (max-width: 600px) {
      .map {
        padding-bottom: 500%;
      }
    }

    .map::before {
      content: "";
      position: absolute;
      inset: 10% 6%;
      background-image: radial-gradient(circle, rgba(148,163,184,0.16) 1px, transparent 1px);
      background-size: 30px 30px;
      opacity: 0.35;
      pointer-events: none;
      z-index: 0;
    }

    .map-lines {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }
    .map-line {
      fill: none;
      stroke: rgba(34,197,94,0.85);
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.75));
    }

    .node {
      position: absolute;
      transform: translate(-50%, -50%);
      min-width: 80px;
      text-align: center;
      z-index: 3;
    }
    .node.locked {
      cursor: default;
    }
    .node.unlocked,
    .node.completed {
      cursor: pointer;
    }

    .node-circle {
      width: 72px;
      height: 72px;
      margin: 0 auto 6px;
      border-radius: 999px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 18px;
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        background 0.12s ease,
        color 0.12s ease;
      box-shadow: 0 4px 0 rgba(15,23,42,0.9);
    }

    .node.locked .node-circle {
      background: #0b1220;
      color: #4b5563;
      box-shadow: 0 3px 0 rgba(15,23,42,0.9);
      border: 1px solid #111827;
    }
    .node.unlocked .node-circle {
      background: #22c55e;
      color: #052e16;
      box-shadow:
        0 4px 0 rgba(15,23,42,0.9),
        0 0 0 4px rgba(34,197,94,0.25);
    }
    .node.completed .node-circle {
      background: #16a34a;
      color: #ecfdf3;
      box-shadow:
        0 5px 0 rgba(15,23,42,0.9),
        0 0 0 5px rgba(22,163,74,0.35);
      transform: translateY(-1px) scale(1.03);
    }
    .node.unlocked:hover .node-circle,
    .node.completed:hover .node-circle {
      transform: translateY(-2px) scale(1.04);
      box-shadow:
        0 7px 14px rgba(0,0,0,0.9),
        0 0 0 5px rgba(34,197,94,0.4);
    }

    .node-title {
      font-size: 16px;
      margin-bottom: 2px;
      color: #e5e7eb;
    }
    .node-progress {
      font-size: 9px;
      color: #9ca3af;
    }

    @media (max-width: 600px) {
      .node-title {
      font-size: 12px;
    }
    }
    
    /* ã€Œã‚ˆãã§ãã¾ã—ãŸï¼ã€ãƒˆãƒ¼ã‚¹ãƒˆ */
    .success-toast {
      position: absolute;
      left: 50%;
      top: 16%;
      transform: translate(-50%, -50%) scale(0.7);
      background: #22c55e;
      color: #022c22;
      font-size: 13px;
      font-weight: 700;
      padding: 6px 18px;
      border-radius: 999px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.75);
      pointer-events: none;
      opacity: 0;
      z-index: 5;
    }
    .success-toast.show {
      animation: success-pop 0.9s ease-out forwards;
    }
    @keyframes success-pop {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.6);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.05);
      }
      60% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
    }
    
/* ç´™å¹é›ª */
.confetti {
  position: absolute;
  width: 6px;
  height: 10px;
  border-radius: 2px;
  opacity: 0;
  pointer-events: none;
  z-index: 4;
  /* ä¸€å®šé€Ÿåº¦ã§å‹•ã‹ã—ãŸã„ã®ã§ linear */
  animation: confetti-fall 900ms linear forwards;
}

@keyframes confetti-fall {
  0% {
    opacity: 0;
    /* ãƒœã‚¿ãƒ³ä½ç½®ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆæ¨ªã¯ 0 å›ºå®šã€ç¸¦ã ã‘å‹•ã‹ã™ï¼‰ */
    transform: translate3d(0, 0, 0) rotateZ(0deg);
  }
  /* ã“ã“ã§ã€Œãƒãƒ³ã€ã¨ä¸Šã«è·³ã­ã‚‹ */
  20% {
    opacity: 1;
    transform: translate3d(0, -80px, 0) rotateZ(120deg);
  }
  /* ã‚ã¨ã¯ãã®ã¾ã¾ä¸‹ã¾ã§ã‚¹ãƒˆãƒ³ã¨è½ã¡ã‚‹ */
  100% {
    opacity: 0;
    transform: translate3d(0, 260px, 0) rotateZ(360deg);
  }
}
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
<div class="top-bar-left">
  <!-- ã€Œæ¬¡ã«ã‚„ã‚‹ã“ã¨ã€è¡¨ç¤º -->
  <h1 id="nextTaskTitle">åŸç¨¿ã™ã”ã‚ããƒãƒƒãƒ—</h1>
  <div class="top-bar-info" id="nextTaskInfo">
    ä¸€ç•ªä¸Šã®ãƒã‚¹ã‹ã‚‰é †ç•ªã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚ã¦ã„ãåŸç¨¿ã™ã”ã‚ãã§ã™ã€‚
  </div>
</div>
      <div class="top-bar-right">
        <div class="streak-box">
          <div class="streak-label">ç¾åœ¨ã®é€£ç¶šæ—¥æ•°</div>
          <div class="streak-value" id="streakValue">0 æ—¥</div>
          <div class="streak-note">â€»æœ5æ™‚åŒºåˆ‡ã‚Šã§ã‚«ã‚¦ãƒ³ãƒˆ</div>
        </div>
        <button class="reset-btn" id="resetProgressBtn">é€²æ—ãƒ»é€£ç¶šæ—¥æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>

    <!-- ãƒšãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆ -->
<div class="page-nav">
  <button id="prevPageBtn">â—€</button>
  <span id="pageLabel" class="page-nav-label">1ãƒšãƒ¼ã‚¸ç›® / å…¨1ãƒšãƒ¼ã‚¸</span>
  <button id="nextPageBtn">â–¶</button>
  <button id="addPageBtn">ï¼‹</button>
  <button id="resetPagesBtn" class="page-reset-btn">ğŸ—‘</button>
</div>

    <div class="board-wrapper">
      <div id="map" class="map"></div>
      <div id="successToast" class="success-toast">ã‚ˆãã§ãã¾ã—ãŸï¼</div>
    </div>
  </div>

  <script>
    // ===== ãƒã‚¹å®šç¾© =====
    const frameCount   = 6;
    const roughCount   = 6;
    const textCount    = 6;
    const penCount     = 6;
    const betaCount    = 6;
    const toneCount    = 6;
    const finishCount  = 6;

    const LESSONS = [];

    function addGroup(prefix, label, descBase, count, prevId) {
      let lastId = prevId;
      for (let i = 1; i <= count; i++) {
        const id = `${prefix}${i}`;
        const title = `${label}${i}ã‚³ãƒç›®`;
        LESSONS.push({
          id,
          title,
          description: descBase.replace("{n}", i),
          maxProgress: 1,
          prereqId: lastId
        });
        lastId = id;
      }
      return lastId;
    }

    let last = null;
    last = addGroup("frame_",  "æ ç·š",   "æ ç·š {n}ã‚³ãƒç›®ã€‚",      frameCount, last);
    last = addGroup("rough_",  "ä¸‹æ›¸ã", "ä¸‹æ›¸ã {n}ã‚³ãƒç›®ã€‚",    roughCount, last);
    last = addGroup("text_",   "å°è©",   "å°è© {n}ã‚³ãƒç›®ã€‚",      textCount,  last);
    last = addGroup("pen_",    "ãƒšãƒ³å…¥ã‚Œ", "ãƒšãƒ³å…¥ã‚Œ {n}ã‚³ãƒç›®ã€‚", penCount,   last);
    last = addGroup("beta_",   "ãƒ™ã‚¿",     "ãƒ™ã‚¿ {n}ã‚³ãƒç›®ã€‚",     betaCount,  last);
    last = addGroup("tone_",   "ãƒˆãƒ¼ãƒ³",   "ãƒˆãƒ¼ãƒ³ {n}ã‚³ãƒç›®ã€‚",   toneCount,  last);
    last = addGroup("finish_", "ä»•ä¸Šã’",   "ä»•ä¸Šã’ {n}ã‚³ãƒç›®ã€‚",   finishCount,last);

    // ===== ãƒšãƒ¼ã‚¸ç®¡ç† =====
    let currentPage = 1;
    const STORAGE_KEY = "mangaLessonProgress_v8_pages";
    const STREAK_KEY  = "mangaLessonStreak_v1";

    function createInitialProgressMap() {
      const obj = {};
      for (const lesson of LESSONS) {
        obj[lesson.id] = 0;
      }
      return obj;
    }

    function createNewData() {
      return {
        maxPage: 1,
        pages: { "1": createInitialProgressMap() }
      };
    }

    function migrateLegacyProgress(legacyObj) {
      const base = createInitialProgressMap();
      for (const id of Object.keys(base)) {
        if (typeof legacyObj[id] === "number") {
          base[id] = legacyObj[id];
        }
      }
      return base;
    }

    function loadAllProgress() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const data = createNewData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
      try {
        const parsed = JSON.parse(raw);
        if (parsed && parsed.pages) {
          for (let p = 1; p <= (parsed.maxPage || 1); p++) {
            const key = String(p);
            if (!parsed.pages[key]) parsed.pages[key] = createInitialProgressMap();
            else {
              const base = createInitialProgressMap();
              const src = parsed.pages[key];
              for (const id of Object.keys(base)) {
                base[id] = typeof src[id] === "number" ? src[id] : 0;
              }
              parsed.pages[key] = base;
            }
          }
          return parsed;
        } else {
          const legacy = (parsed && typeof parsed === "object") ? parsed : {};
          const data = createNewData();
          data.pages["1"] = migrateLegacyProgress(legacy);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
          return data;
        }
      } catch {
        const data = createNewData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
    }

    function saveAllProgress(data) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function loadPageProgress(page) {
      const data = loadAllProgress();
      const key = String(page);
      if (!data.pages[key]) {
        data.pages[key] = createInitialProgressMap();
        if (page > data.maxPage) data.maxPage = page;
        saveAllProgress(data);
      }
      return { data, progress: data.pages[key] };
    }

    function resetAllPagesProgress() {
      const data = loadAllProgress();
      for (let p = 1; p <= data.maxPage; p++) {
        data.pages[String(p)] = createInitialProgressMap();
      }
      saveAllProgress(data);
    }

    // ===== ã‚°ãƒªãƒƒãƒ‰é…ç½®ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ï¼šPC=6åˆ—, 600pxä»¥ä¸‹=3åˆ—ï¼‰ =====
    function getPerRow() {
      return window.innerWidth <= 600 ? 3 : 6;
    }

    function computeGridPositions(count, perRow) {
      const positions = [];
      const rows = Math.ceil(count / perRow);

      // æ¨ªæ–¹å‘ï¼šå·¦å³ã«å°‘ã—ä½™ç™½
      let marginX;
      if (perRow === 3) {
        marginX = 12;
      } else {
        marginX = 8;
      }
      const usableX = 100 - marginX * 2;
      const stepX   = perRow > 1 ? usableX / (perRow - 1) : 0;

      // ç¸¦æ–¹å‘
      let marginTop;
      let totalY;
      if (perRow === 3) {
        marginTop = 5;
        totalY    = 90;
      } else {
        marginTop = 8;
        totalY    = 70;
      }
      const rowStep = rows > 1 ? totalY / (rows - 1) : 0;

      for (let i = 0; i < count; i++) {
        const row = Math.floor(i / perRow);
        const indexInRow = i % perRow;
        const isEvenRow = (row % 2 === 0);
        const col = isEvenRow ? indexInRow : perRow - 1 - indexInRow;

        const x = marginX + stepX * col;
        const y = marginTop + rowStep * row;
        positions.push({ x, y });
      }
      return positions;
    }

    // ===== æ—¥ä»˜ï¼ˆæœ5æ™‚åŒºåˆ‡ã‚Šï¼‰ =====
    function getLogicalDateKey(date = new Date()) {
      const d = new Date(date.getTime());
      const hour = d.getHours();
      if (hour < 5) d.setDate(d.getDate() - 1);

      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function keyToDate(key) {
      const [y, m, d] = key.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function dateToKey(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    // ===== é€£ç¶šæ—¥æ•° =====
    function loadStreakData() {
      const raw = localStorage.getItem(STREAK_KEY);
      if (!raw) return {};
      try {
        const obj = JSON.parse(raw);
        return obj && typeof obj === "object" ? obj : {};
      } catch {
        return {};
      }
    }

    function saveStreakData(data) {
      localStorage.setItem(STREAK_KEY, JSON.stringify(data));
    }

    function resetStreakData() {
      saveStreakData({});
    }

    function registerActivity() {
      const data = loadStreakData();
      const todayKey = getLogicalDateKey();
      if (!data[todayKey]) {
        data[todayKey] = true;
        saveStreakData(data);
      }
    }

    function calcCurrentStreak() {
      const data = loadStreakData();
      const keys = Object.keys(data);
      if (keys.length === 0) return 0;

      const set = new Set(keys);
      let streak = 0;
      let d = keyToDate(getLogicalDateKey());
      while (true) {
        const key = dateToKey(d);
        if (set.has(key)) {
          streak += 1;
          d.setDate(d.getDate() - 1);
        } else {
          break;
        }
      }
      return streak;
    }

    function updateStreakDisplay() {
      const el = document.getElementById("streakValue");
      if (!el) return;
      el.textContent = `${calcCurrentStreak()} æ—¥`;
    }

    // ===== ãƒšãƒ¼ã‚¸è¡¨ç¤ºæ›´æ–° =====
    function updatePageLabel(dataOpt) {
      const labelEl = document.getElementById("pageLabel");
      const prevBtn = document.getElementById("prevPageBtn");
      const nextBtn = document.getElementById("nextPageBtn");
      const data = dataOpt || loadAllProgress();
      if (!labelEl) return;
      labelEl.textContent = `${currentPage}ãƒšãƒ¼ã‚¸ç›® / å…¨${data.maxPage}ãƒšãƒ¼ã‚¸`;
      if (prevBtn) prevBtn.disabled = currentPage <= 1;
      if (nextBtn) nextBtn.disabled = currentPage >= data.maxPage;
    }

    // ã¾ã çµ‚ã‚ã£ã¦ã„ãªã„æœ€åˆã®ãƒ¬ãƒƒã‚¹ãƒ³ã‚’æ¢ã™
    function getNextIncompleteLesson(progress) {
      for (const lesson of LESSONS) {
        if (!isLessonCompleted(lesson, progress)) {
          return lesson;
        }
      }
      return null;
    }

    // ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã€Œæ¬¡ã«ã‚„ã‚‹ã“ã¨ã€ã‚’è¡¨ç¤º
    function updateNextTaskDisplay(progress) {
      const titleEl = document.getElementById("nextTaskTitle");
      const infoEl  = document.getElementById("nextTaskInfo");
      if (!titleEl || !infoEl) return;

      const next = getNextIncompleteLesson(progress);

      if (next) {
        titleEl.textContent = `${next.title}ã‚’é€²ã‚ã‚ˆã†ï¼`;
        infoEl.textContent  = `æ¬¡ã®ãƒã‚¹ã¯ã€Œ${next.title}ã€ã§ã™ã€‚ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚ã¦ã„ãã¾ã—ã‚‡ã†ã€‚`;
      } else {
        titleEl.textContent = "ã“ã®ãƒšãƒ¼ã‚¸ã¯å…¨éƒ¨ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼";
        infoEl.textContent  = "ãŠç–²ã‚Œã•ã¾ã§ã—ãŸã€‚æ–°ã—ã„ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ ã—ã¦ç¶šãã®åŸç¨¿ã‚’é€²ã‚ã¾ã—ã‚‡ã†ã€‚";
      }
    }
    
    // ===== æˆåŠŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆ =====
    let audioCtx = null;

    function showSuccessEffect() {
      const toast = document.getElementById("successToast");
      if (!toast) return;
      toast.classList.remove("show");
      void toast.offsetWidth;
      toast.classList.add("show");
    }

    function triggerConfetti(targetNode) {
      const mapEl = document.getElementById("map");
      if (!mapEl) return;

      const mapRect = mapEl.getBoundingClientRect();

      let baseXPercent = 50;
      let baseYPercent = 20;

      if (targetNode) {
        const nodeRect = targetNode.getBoundingClientRect();
        const centerX = (nodeRect.left + nodeRect.right) / 2 - mapRect.left;
        const centerY = (nodeRect.top + nodeRect.bottom) / 2 - mapRect.top;
        baseXPercent = (centerX / mapRect.width) * 100;
        baseYPercent = (centerY / mapRect.height) * 100;
      }

      const count  = 45;
      const colors = ["#22c55e", "#facc15", "#38bdf8", "#f97316", "#a855f7"];

      for (let i = 0; i < count; i++) {
        const piece = document.createElement("div");
        piece.className = "confetti";

        const offsetX = (Math.random() * 30) - 15; // -15ã€œ+15
        piece.style.left = (baseXPercent + offsetX) + "%";
        piece.style.top  = baseYPercent + "%";

        piece.style.backgroundColor = colors[i % colors.length];
        piece.style.animationDelay  = (Math.random() * 0.18) + "s";

        mapEl.appendChild(piece);

        setTimeout(() => piece.remove(), 1000);
      }
    }
    
    function playSuccessSound(isFinal) {
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return;
        if (!audioCtx) audioCtx = new Ctx();
        const ctx = audioCtx;
        const now = ctx.currentTime;

        function tone(freq, start, duration, volume, type = "sine") {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, start);
          gain.gain.setValueAtTime(0.0001, start);
          gain.gain.exponentialRampToValueAtTime(volume, start + 0.03);
          gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
          osc.connect(gain).connect(ctx.destination);
          osc.start(start);
          osc.stop(start + duration + 0.02);
        }

        function sparkleNoise(start, duration, volume) {
          const bufferSize = duration * ctx.sampleRate;
          const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
          const data = noiseBuffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * 0.4;
          }
          const noise = ctx.createBufferSource();
          noise.buffer = noiseBuffer;
          const gain = ctx.createGain();
          gain.gain.setValueAtTime(volume, start);
          gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
          noise.connect(gain).connect(ctx.destination);
          noise.start(start);
          noise.stop(start + duration + 0.05);
        }

        if (!isFinal) {
          tone(1320, now, 0.25, 0.25, "sine");
          tone(660,  now + 0.02, 0.35, 0.18, "triangle");
          tone(880,  now + 0.02, 0.35, 0.18, "triangle");
          sparkleNoise(now, 0.25, 0.08);
          return;
        }

        const base = 523.25; // C5
        const step = 0.12;
        tone(base,           now + 0.00, 0.4, 0.26, "triangle");
        tone(base * 1.25,    now + step, 0.4, 0.24, "triangle");
        tone(base * 1.5,     now + step*2, 0.4, 0.22, "triangle");
        tone(base * 2,       now + step*3, 0.5, 0.28, "sine");

        tone(261.63, now, 0.6, 0.20, "sine");
        sparkleNoise(now, 0.45, 0.12);

      } catch (e) {
        console.warn("audio error", e);
      }
    }

    // ===== ãƒ¬ãƒƒã‚¹ãƒ³çŠ¶æ…‹ =====
    function isLessonUnlocked(lesson, progress) {
      if (!lesson.prereqId) return true;
      const prereq = LESSONS.find(l => l.id === lesson.prereqId);
      if (!prereq) return true;
      return progress[prereq.id] >= prereq.maxProgress;
    }

    function isLessonCompleted(lesson, progress) {
      return progress[lesson.id] >= lesson.maxProgress;
    }

    function advanceLesson(lessonId) {
      const { data, progress } = loadPageProgress(currentPage);
      const lesson = LESSONS.find(l => l.id === lessonId);
      if (!lesson) return;

      if (!isLessonUnlocked(lesson, progress)) {
        logMessage(`ã€Œ${lesson.title}ã€ã¯ã¾ã å…ˆã®ãƒã‚¹ã§ã™ã€‚æ‰‹å‰ã®ãƒã‚¹ã‹ã‚‰é †ç•ªã«é€²ã‚ã¦ãã ã•ã„ã€‚`);
        return;
      }
      if (progress[lesson.id] >= lesson.maxProgress) {
        logMessage(`ã€Œ${lesson.title}ã€ã¯æ—¢ã«ã‚¯ãƒªã‚¢ã—ã¦ã„ã¾ã™ã€‚`);
        return;
      }

      progress[lesson.id] += 1;
      saveAllProgress(data);

      logMessage(`ã€Œ${lesson.title}ã€ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚ï¼ˆ${currentPage}ãƒšãƒ¼ã‚¸ç›®ï¼‰`);
      registerActivity();
      updateStreakDisplay();

      const isFinal = lesson.id === "finish_6";

      renderAll();

      const mapEl = document.getElementById("map");
      const targetNode = mapEl
        ? mapEl.querySelector(`.node[data-lesson-id="${lessonId}"]`)
        : null;

      showSuccessEffect();
      triggerConfetti(targetNode);
      playSuccessSound(isFinal);
    }
    
    // ===== ãƒ­ã‚° =====
    function logMessage(text) {
      console.log(text);
    }

    // ===== ãƒãƒƒãƒ—æç”» =====
    function renderMap(progress) {
      const mapEl = document.getElementById("map");
      mapEl.innerHTML = "";

      const perRow = getPerRow();
      const positions = computeGridPositions(LESSONS.length, perRow);

      LESSONS.forEach((lesson, index) => {
        const unlocked = isLessonUnlocked(lesson, progress);
        const completed = isLessonCompleted(lesson, progress);
        const pos = positions[index];

        const node = document.createElement("div");
        node.className = "node";
        node.dataset.lessonId = lesson.id;
        node.style.left = pos.x + "%";
        node.style.top = pos.y + "%";

        if (!unlocked) node.classList.add("locked");
        if (unlocked) node.classList.add("unlocked");
        if (completed) node.classList.add("completed");

        const circle = document.createElement("div");
        circle.className = "node-circle";
        circle.textContent = index + 1;

        const title = document.createElement("div");
        title.className = "node-title";
        title.textContent = lesson.title;

        const progressText = document.createElement("div");
        progressText.className = "node-progress";
        if (completed) {
          progressText.textContent = "ã‚¯ãƒªã‚¢æ¸ˆã¿";
        } else if (unlocked) {
          progressText.textContent = "ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚€";
        } else {
          progressText.textContent = "ãƒ­ãƒƒã‚¯ä¸­";
        }

        node.appendChild(circle);
        node.appendChild(title);
        node.appendChild(progressText);

        node.addEventListener("click", () => advanceLesson(lesson.id));
        mapEl.appendChild(node);
      });

      requestAnimationFrame(drawLinesFromDom);
    }

    function drawLinesFromDom() {
      const mapEl = document.getElementById("map");
      if (!mapEl) return;

      const oldSvg = mapEl.querySelector(".map-lines");
      if (oldSvg) oldSvg.remove();

      const nodes = Array.from(mapEl.querySelectorAll(".node"));
      if (nodes.length < 2) return;

      const mapRect = mapEl.getBoundingClientRect();
      const centers = nodes.map(node => {
        const r = node.getBoundingClientRect();
        const cx = (r.left + r.right) / 2 - mapRect.left;
        const cy = (r.top + r.bottom) / 2 - mapRect.top;
        return { x: cx, y: cy };
      });

      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("class", "map-lines");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", `0 0 ${mapRect.width} ${mapRect.height}`);
      svg.setAttribute("preserveAspectRatio", "none");

      for (let i = 0; i < centers.length - 1; i++) {
        const p1 = centers[i];
        const p2 = centers[i + 1];
        const path = document.createElementNS(svgNS, "path");
        const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        path.setAttribute("d", d);
        path.setAttribute("class", "map-line");
        svg.appendChild(path);
      }

      mapEl.insertBefore(svg, mapEl.firstChild);
    }

    function renderAll() {
      const { data, progress } = loadPageProgress(currentPage);
      renderMap(progress);
      updateStreakDisplay();
      updatePageLabel(data);
      updateNextTaskDisplay(progress);
    }

    window.addEventListener("DOMContentLoaded", () => {
      renderAll();

      document.getElementById("resetProgressBtn").addEventListener("click", () => {
        if (!confirm("æœ¬å½“ã«å…¨ãƒšãƒ¼ã‚¸ã®é€²æ—ã¨é€£ç¶šæ—¥æ•°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
        resetAllPagesProgress();
        resetStreakData();
        renderAll();
      });

      document.getElementById("prevPageBtn").addEventListener("click", () => {
        if (currentPage > 1) {
          currentPage--;
          renderAll();
        }
      });
      document.getElementById("nextPageBtn").addEventListener("click", () => {
        const data = loadAllProgress();
        if (currentPage < data.maxPage) {
          currentPage++;
          renderAll();
        }
      });
      document.getElementById("addPageBtn").addEventListener("click", () => {
        const data = loadAllProgress();
        const newPage = data.maxPage + 1;
        data.maxPage = newPage;
        data.pages[String(newPage)] = createInitialProgressMap();
        saveAllProgress(data);
        currentPage = newPage;
        logMessage(`${newPage}ãƒšãƒ¼ã‚¸ç›®ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚`);
        renderAll();
      });

      document.getElementById("resetPagesBtn").addEventListener("click", () => {
        if (!confirm("å…¨ãƒšãƒ¼ã‚¸ã‚’å‰Šé™¤ã—ã¦ 1ãƒšãƒ¼ã‚¸ç›®ã ã‘æ®‹ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;

        const data = loadAllProgress();
        data.maxPage = 1;
        data.pages = { "1": createInitialProgressMap() };

        saveAllProgress(data);

        currentPage = 1;
        renderAll();
        logMessage("ãƒšãƒ¼ã‚¸æ•°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚");
      });

      window.addEventListener("resize", () => {
        renderAll();
      });
    });
  </script>
</body>
</html>
