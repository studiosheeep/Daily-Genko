<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>原稿マップ・すごろく</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 404 対策：空の favicon を指定 -->
  <link rel="icon" href="data:,">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 4px;
    }
    .app-container {
      max-width: 960px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      padding: 16px;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: stretch;
      margin-bottom: 12px;
      gap: 8px;
      flex-wrap: wrap;
    }
    .top-bar-left {
      flex: 1 1 auto;
      min-width: 180px;
    }
    .top-bar-info {
      font-size: 13px;
      color: #555;
    }
    .top-bar-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      flex: 0 0 auto;
      min-width: 160px;
    }
    .streak-box {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 11px;
      background: #fafafa;
      text-align: right;
    }
    .streak-label {
      color: #555;
      margin-bottom: 2px;
    }
    .streak-value {
      font-size: 16px;
      font-weight: bold;
      color: #c56;
    }
    .streak-note {
      color: #888;
      font-size: 10px;
      margin-top: 2px;
    }
    .reset-btn {
      border: 1px solid #d33;
      background: #fff5f5;
      color: #b00;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      align-self: flex-end;
    }
    .reset-btn:hover {
      background: #ffe5e5;
    }

    /* ページナビ */
    .page-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .page-nav button {
      border: 1px solid #ccc;
      background: #fafafa;
      border-radius: 999px;
      padding: 2px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .page-nav button:hover:not(:disabled) {
      background: #f0f0f0;
    }
    .page-nav button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .page-nav-label {
      min-width: 140px;
      text-align: center;
    }

    .board-wrapper {
      margin-bottom: 0; /* 下のアクションログを消したので余白も詰める */
      position: relative;
    }
    .map {
      position: relative;
      width: 100%;
      padding-bottom: 160%;  /* PC 基準 */
      border-radius: 12px;
      background:
        radial-gradient(circle at 10% 20%, #fef9e7 0, #fef9e7 40%, transparent 41%),
        radial-gradient(circle at 80% 70%, #e8f9ff 0, #e8f9ff 35%, transparent 36%),
        #fdfdfd;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    /* 600px以下でマップを縦長に */
    @media (max-width: 600px) {
      .map {
        padding-bottom: 500%;
      }
    }

    .map::before {
      content: "";
      position: absolute;
      inset: 8% 4%;
      background-image: radial-gradient(circle, rgba(255,150,120,0.6) 2px, transparent 2px);
      background-size: 32px 32px;
      opacity: 0.25;
      pointer-events: none;
      z-index: 0;
    }
    .map-lines {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }
    .map-line {
      fill: none;
      stroke: rgba(255, 152, 0, 0.7);
      stroke-width: 4;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .node {
      position: absolute;
      transform: translate(-50%, -50%);
      min-width: 80px;
      text-align: center;
      z-index: 3;
    }
    .node.locked {
      cursor: not-allowed;
    }
    .node.unlocked,
    .node.completed {
      cursor: pointer;
    }
    .node-circle {
      width: 64px;
      height: 64px;
      margin: 0 auto 6px;
      border-radius: 50%;
      border: 2px solid #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fefefe;
      font-weight: bold;
      font-size: 16px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.1s ease, background 0.1s ease;
    }
    .node.locked .node-circle {
      background: #f0f0f0;
      border-style: dashed;
      color: #aaa;
    }
    .node.unlocked .node-circle {
      border-color: #36a;
      background: #ffffff;
    }
    .node.completed .node-circle {
      background: #36a;
      border-color: #247;
      color: #fff;
      box-shadow: 0 0 0 3px rgba(54,106,170,0.25);
    }
    .node.unlocked:hover .node-circle,
    .node.completed:hover .node-circle {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .node-title {
      font-size: 11px;
      margin-bottom: 2px;
    }
    .node-progress {
      font-size: 10px;
      color: #555;
    }

    /* 「よくできました！」トースト */
    .success-toast {
      position: absolute;
      left: 50%;
      top: 10%;
      transform: translate(-50%, -50%) scale(0.6);
      background: rgba(255,255,255,0.96);
      color: #c56;
      font-size: 14px;
      font-weight: bold;
      padding: 6px 18px;
      border-radius: 999px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      pointer-events: none;
      opacity: 0;
      z-index: 5;
    }
    .success-toast.show {
      animation: success-pop 0.9s ease-out forwards;
    }
    @keyframes success-pop {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.6);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.05);
      }
      60% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div class="top-bar-left">
        <h1>原稿すごろくマップ</h1>
        <div class="top-bar-info">
          一番上のマスから順番にクリックして進めていく原稿すごろくです。
        </div>
      </div>
      <div class="top-bar-right">
        <div class="streak-box">
          <div class="streak-label">現在の連続日数</div>
          <div class="streak-value" id="streakValue">0 日</div>
          <div class="streak-note">※朝5時区切りでカウント</div>
        </div>
        <button class="reset-btn" id="resetProgressBtn">進捗・連続日数をリセット</button>
      </div>
    </div>

    <!-- ページ切り替え -->
    <div class="page-nav">
      <button id="prevPageBtn">◀</button>
      <span id="pageLabel" class="page-nav-label">1ページ目 / 全1ページ</span>
      <button id="nextPageBtn">▶</button>
      <button id="addPageBtn">＋</button>
    </div>

    <div class="board-wrapper">
      <div id="map" class="map"></div>
      <div id="successToast" class="success-toast">よくできました！</div>
    </div>
  </div>

  <script>
    // ===== マス定義 =====
    const frameCount   = 6;
    const roughCount   = 6;
    const textCount    = 6;
    const penCount     = 6;
    const betaCount    = 6;
    const toneCount    = 6;
    const finishCount  = 6;

    const LESSONS = [];

    function addGroup(prefix, label, descBase, count, prevId) {
      let lastId = prevId;
      for (let i = 1; i <= count; i++) {
        const id = `${prefix}${i}`;
        const title = `${label}${i}コマ目`;
        LESSONS.push({
          id,
          title,
          description: descBase.replace("{n}", i),
          maxProgress: 1,
          prereqId: lastId
        });
        lastId = id;
      }
      return lastId;
    }

    let last = null;
    last = addGroup("frame_",  "枠線",   "枠線 {n}コマ目。",      frameCount, last);
    last = addGroup("rough_",  "下書き", "下書き {n}コマ目。",    roughCount, last);
    last = addGroup("text_",   "台詞",   "台詞 {n}コマ目。",      textCount,  last);
    last = addGroup("pen_",    "ペン入れ", "ペン入れ {n}コマ目。", penCount,   last);
    last = addGroup("beta_",   "ベタ",     "ベタ {n}コマ目。",     betaCount,  last);
    last = addGroup("tone_",   "トーン",   "トーン {n}コマ目。",   toneCount,  last);
    last = addGroup("finish_", "仕上げ",   "仕上げ {n}コマ目。",   finishCount,last);

    // ===== ページ管理 =====
    let currentPage = 1;
    const STORAGE_KEY = "mangaLessonProgress_v7_pages";
    const STREAK_KEY  = "mangaLessonStreak_v1";

    function createInitialProgressMap() {
      const obj = {};
      for (const lesson of LESSONS) {
        obj[lesson.id] = 0;
      }
      return obj;
    }

    function createNewData() {
      return {
        maxPage: 1,
        pages: { "1": createInitialProgressMap() }
      };
    }

    function migrateLegacyProgress(legacyObj) {
      const base = createInitialProgressMap();
      for (const id of Object.keys(base)) {
        if (typeof legacyObj[id] === "number") {
          base[id] = legacyObj[id];
        }
      }
      return base;
    }

    function loadAllProgress() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const data = createNewData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
      try {
        const parsed = JSON.parse(raw);
        if (parsed && parsed.pages) {
          for (let p = 1; p <= (parsed.maxPage || 1); p++) {
            const key = String(p);
            if (!parsed.pages[key]) parsed.pages[key] = createInitialProgressMap();
            else {
              const base = createInitialProgressMap();
              const src = parsed.pages[key];
              for (const id of Object.keys(base)) {
                base[id] = typeof src[id] === "number" ? src[id] : 0;
              }
              parsed.pages[key] = base;
            }
          }
          return parsed;
        } else {
          const legacy = (parsed && typeof parsed === "object") ? parsed : {};
          const data = createNewData();
          data.pages["1"] = migrateLegacyProgress(legacy);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
          return data;
        }
      } catch {
        const data = createNewData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
    }

    function saveAllProgress(data) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function loadPageProgress(page) {
      const data = loadAllProgress();
      const key = String(page);
      if (!data.pages[key]) {
        data.pages[key] = createInitialProgressMap();
        if (page > data.maxPage) data.maxPage = page;
        saveAllProgress(data);
      }
      return { data, progress: data.pages[key] };
    }

    function resetAllPagesProgress() {
      const data = loadAllProgress();
      for (let p = 1; p <= data.maxPage; p++) {
        data.pages[String(p)] = createInitialProgressMap();
      }
      saveAllProgress(data);
    }

// ===== グリッド配置（レスポンシブ：PC=6列, 600px以下=3列） =====
function getPerRow() {
  return window.innerWidth <= 600 ? 3 : 6;
}

function computeGridPositions(count, perRow) {
  const positions = [];
  const rows = Math.ceil(count / perRow);

  // ★ 横方向：左右にマージンを取る
  let marginX;
  if (perRow === 3) {
    // スマホのときは少し多めに余白を取る
    marginX = 12;       // ← ここを増やすほど左右の余白が広がる
  } else {
    marginX = 8;
  }
  const usableX = 100 - marginX * 2;            // 使える横幅
  const stepX   = perRow > 1 ? usableX / (perRow - 1) : 0;

  // 縦方向
  let marginTop;
  let totalY;
  if (perRow === 3) {
    marginTop = 5;
    totalY    = 90;
  } else {
    marginTop = 8;
    totalY    = 70;
  }
  const rowStep = rows > 1 ? totalY / (rows - 1) : 0;

  for (let i = 0; i < count; i++) {
    const row = Math.floor(i / perRow);
    const indexInRow = i % perRow;
    const isEvenRow = (row % 2 === 0);
    const col = isEvenRow ? indexInRow : perRow - 1 - indexInRow;

    const x = marginX + stepX * col;          // ← 余白込みの X 座標
    const y = marginTop + rowStep * row;

    positions.push({ x, y });
  }
  return positions;
}
    // ===== 日付（朝5時区切り） =====
    function getLogicalDateKey(date = new Date()) {
      const d = new Date(date.getTime());
      const hour = d.getHours();
      if (hour < 5) d.setDate(d.getDate() - 1);

      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function keyToDate(key) {
      const [y, m, d] = key.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function dateToKey(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    // ===== 連続日数 =====
    function loadStreakData() {
      const raw = localStorage.getItem(STREAK_KEY);
      if (!raw) return {};
      try {
        const obj = JSON.parse(raw);
        return obj && typeof obj === "object" ? obj : {};
      } catch {
        return {};
      }
    }

    function saveStreakData(data) {
      localStorage.setItem(STREAK_KEY, JSON.stringify(data));
    }

    function resetStreakData() {
      saveStreakData({});
    }

    function registerActivity() {
      const data = loadStreakData();
      const todayKey = getLogicalDateKey();
      if (!data[todayKey]) {
        data[todayKey] = true;
        saveStreakData(data);
      }
    }

    function calcCurrentStreak() {
      const data = loadStreakData();
      const keys = Object.keys(data);
      if (keys.length === 0) return 0;

      const set = new Set(keys);
      let streak = 0;
      let d = keyToDate(getLogicalDateKey());
      while (true) {
        const key = dateToKey(d);
        if (set.has(key)) {
          streak += 1;
          d.setDate(d.getDate() - 1);
        } else {
          break;
        }
      }
      return streak;
    }

    function updateStreakDisplay() {
      const el = document.getElementById("streakValue");
      if (!el) return;
      el.textContent = `${calcCurrentStreak()} 日`;
    }

    // ===== ページ表示更新 =====
    function updatePageLabel(dataOpt) {
      const labelEl = document.getElementById("pageLabel");
      const prevBtn = document.getElementById("prevPageBtn");
      const nextBtn = document.getElementById("nextPageBtn");
      const data = dataOpt || loadAllProgress();
      if (!labelEl) return;
      labelEl.textContent = `${currentPage}ページ目 / 全${data.maxPage}ページ`;
      if (prevBtn) prevBtn.disabled = currentPage <= 1;
      if (nextBtn) nextBtn.disabled = currentPage >= data.maxPage;
    }

    // ===== 成功エフェクト =====
    let audioCtx = null;

    function showSuccessEffect() {
      const toast = document.getElementById("successToast");
      if (!toast) return;
      toast.classList.remove("show");
      void toast.offsetWidth;
      toast.classList.add("show");
    }

    function playSuccessSound() {
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return;
        if (!audioCtx) audioCtx = new Ctx();

        const ctx = audioCtx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        const now = ctx.currentTime;
        osc.type = "triangle";
        osc.frequency.setValueAtTime(880, now);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.25, now + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);

        osc.connect(gain).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.4);
      } catch (e) {
        console.warn("audio error", e);
      }
    }

    // ===== レッスン状態 =====
    function isLessonUnlocked(lesson, progress) {
      if (!lesson.prereqId) return true;
      const prereq = LESSONS.find(l => l.id === lesson.prereqId);
      if (!prereq) return true;
      return progress[prereq.id] >= prereq.maxProgress;
    }

    function isLessonCompleted(lesson, progress) {
      return progress[lesson.id] >= lesson.maxProgress;
    }

    // ログはコンソール出力だけにする（DOM には触らない）
    function logMessage(text) {
      console.log(text);
    }

    function advanceLesson(lessonId) {
      const { data, progress } = loadPageProgress(currentPage);
      const lesson = LESSONS.find(l => l.id === lessonId);
      if (!lesson) return;

      if (!isLessonUnlocked(lesson, progress)) {
        logMessage(`「${lesson.title}」はまだ先のマスです。手前のマスから順番に進めてください。`);
        return;
      }
      if (progress[lesson.id] >= lesson.maxProgress) {
        logMessage(`「${lesson.title}」は既にクリアしています。`);
        return;
      }

      progress[lesson.id] += 1;
      saveAllProgress(data);

      logMessage(`「${lesson.title}」をクリアしました。（${currentPage}ページ目）`);
      registerActivity();
      updateStreakDisplay();

      showSuccessEffect();
      playSuccessSound();

      renderAll();
    }

    // ===== マップ描画 =====
    function renderMap(progress) {
      const mapEl = document.getElementById("map");
      mapEl.innerHTML = "";

      const perRow = getPerRow();
      const positions = computeGridPositions(LESSONS.length, perRow);

      LESSONS.forEach((lesson, index) => {
        const unlocked = isLessonUnlocked(lesson, progress);
        const completed = isLessonCompleted(lesson, progress);
        const pos = positions[index];

        const node = document.createElement("div");
        node.className = "node";
        node.dataset.lessonId = lesson.id;
        node.style.left = pos.x + "%";
        node.style.top = pos.y + "%";

        if (!unlocked) node.classList.add("locked");
        if (unlocked) node.classList.add("unlocked");
        if (completed) node.classList.add("completed");

        const circle = document.createElement("div");
        circle.className = "node-circle";
        circle.textContent = index + 1;

        const title = document.createElement("div");
        title.className = "node-title";
        title.textContent = lesson.title;

        const progressText = document.createElement("div");
        progressText.className = "node-progress";
        if (completed) {
          progressText.textContent = "クリア済み";
        } else if (unlocked) {
          progressText.textContent = "クリックして進む";
        } else {
          progressText.textContent = "ロック中";
        }

        node.appendChild(circle);
        node.appendChild(title);
        node.appendChild(progressText);

        node.addEventListener("click", () => advanceLesson(lesson.id));
        mapEl.appendChild(node);
      });

      requestAnimationFrame(drawLinesFromDom);
    }

    function drawLinesFromDom() {
      const mapEl = document.getElementById("map");
      if (!mapEl) return;

      const oldSvg = mapEl.querySelector(".map-lines");
      if (oldSvg) oldSvg.remove();

      const nodes = Array.from(mapEl.querySelectorAll(".node"));
      if (nodes.length < 2) return;

      const mapRect = mapEl.getBoundingClientRect();
      const centers = nodes.map(node => {
        const r = node.getBoundingClientRect();
        const cx = (r.left + r.right) / 2 - mapRect.left;
        const cy = (r.top + r.bottom) / 2 - mapRect.top;
        return { x: cx, y: cy };
      });

      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("class", "map-lines");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", `0 0 ${mapRect.width} ${mapRect.height}`);
      svg.setAttribute("preserveAspectRatio", "none");

      for (let i = 0; i < centers.length - 1; i++) {
        const p1 = centers[i];
        const p2 = centers[i + 1];
        const path = document.createElementNS(svgNS, "path");
        const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        path.setAttribute("d", d);
        path.setAttribute("class", "map-line");
        svg.appendChild(path);
      }

      mapEl.insertBefore(svg, mapEl.firstChild);
    }

    function renderAll() {
      const { data, progress } = loadPageProgress(currentPage);
      renderMap(progress);
      updateStreakDisplay();
      updatePageLabel(data);
    }

    window.addEventListener("DOMContentLoaded", () => {
      renderAll();

      document.getElementById("resetProgressBtn").addEventListener("click", () => {
        if (!confirm("本当に全ページの進捗と連続日数をリセットしますか？")) return;
        resetAllPagesProgress();
        resetStreakData();
        renderAll();
        logMessage("全ページの進捗と連続日数をリセットしました。");
      });

      document.getElementById("prevPageBtn").addEventListener("click", () => {
        if (currentPage > 1) {
          currentPage--;
          renderAll();
        }
      });
      document.getElementById("nextPageBtn").addEventListener("click", () => {
        const data = loadAllProgress();
        if (currentPage < data.maxPage) {
          currentPage++;
          renderAll();
        }
      });
      document.getElementById("addPageBtn").addEventListener("click", () => {
        const data = loadAllProgress();
        const newPage = data.maxPage + 1;
        data.maxPage = newPage;
        data.pages[String(newPage)] = createInitialProgressMap();
        saveAllProgress(data);
        currentPage = newPage;
        logMessage(`${newPage}ページ目を追加しました。`);
        renderAll();
      });

      // 画面幅が変わったらレイアウトを再計算
      window.addEventListener("resize", () => {
        renderAll();
      });
    });
  </script>
</body>
</html>
