<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>原稿マップ・すごろく</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- favicon 404 対策（小さな緑丸アイコン） -->
  <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' fill='%2322c55e'/%3E%3C/svg%3E">

  <style>
    /* ===== 全体レイアウト（ダーク＋フラット基調） ===== */
    :root {
      color-scheme: dark;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #020617;
      color: #e5e7eb;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 4px;
      color: #f9fafb;
    }
    .app-container {
      max-width: 960px;
      margin: 0 auto;
      background: radial-gradient(circle at top left, #1f2937 0, #020617 55%);
      border-radius: 24px;
      box-shadow:
        0 24px 60px rgba(0,0,0,0.55),
        0 0 0 1px rgba(15,23,42,0.9);
      padding: 18px 16px 20px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: stretch;
      margin-bottom: 12px;
      gap: 8px;
      flex-wrap: wrap;
    }
    .top-bar-left {
      flex: 1 1 auto;
      min-width: 180px;
    }
    .top-bar-info {
      font-size: 13px;
      color: #9ca3af;
    }
    .top-bar-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      flex: 0 0 auto;
      min-width: 160px;
    }

/* 600px 以下のときはヘッダーを縦並び＆右側ブロックを中央寄せ */
@media (max-width: 600px) {
  .top-bar {
    flex-direction: column;
    align-items: stretch;
  }

  .top-bar-right {
    align-items: center;   /* 中央にそろえる */
    text-align: center;
    margin-top: 8px;       /* 上に少し余白 */
  }
}
    .streak-box {
      border-radius: 16px;
      padding: 8px 10px;
      font-size: 11px;
      background: linear-gradient(135deg,#0f172a,#020617);
      border: 1px solid #111827;
      text-align: right;
      box-shadow: 0 0 0 1px rgba(15,23,42,0.7);
    }
    .streak-label {
      color: #9ca3af;
      margin-bottom: 2px;
    }
    .streak-value {
      font-size: 18px;
      font-weight: 800;
      color: #facc15;
    }
    .streak-note {
      color: #6b7280;
      font-size: 10px;
      margin-top: 2px;
    }

    .reset-btn {
      border-radius: 999px;
      border: 1px solid #f97373;
      background: rgba(248,113,113,0.1);
      color: #fecaca;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      align-self: flex-end;
      font-weight: 500;
    }
    .reset-btn:hover {
      background: rgba(248,113,113,0.18);
    }

    /* ===== ページナビ（フラットボタン風） ===== */
    .page-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      color: #e5e7eb;
    }
    .page-nav button {
      border: 1px solid #1f2937;
      background: #020617;
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 12px;
      cursor: pointer;
      color: #e5e7eb;
      box-shadow: 0 2px 0 rgba(15,23,42,0.9);
    }
    .page-nav button:hover:not(:disabled) {
      background: #111827;
    }
    .page-nav button:active:not(:disabled) {
      transform: translateY(1px);
      box-shadow: 0 1px 0 rgba(15,23,42,0.9);
    }
    .page-nav button:disabled {
      opacity: 0.35;
      cursor: default;
      box-shadow: none;
    }
    .page-nav-label {
      min-width: 150px;
      text-align: center;
      font-weight: 500;
      color: #e5e7eb;
    }

    /* ===== マップエリア（Duolingo 風） ===== */
    .board-wrapper {
      margin-bottom: 4px;
      position: relative;
    }
    .map {
      position: relative;
      width: 100%;
      padding-bottom: 160%; /* PC 基準 */
      border-radius: 20px;
      background:
        radial-gradient(circle at 20% 0%, rgba(56,189,248,0.12) 0, transparent 55%),
        radial-gradient(circle at 80% 90%, rgba(34,197,94,0.16) 0, transparent 55%),
        #020617;
      box-shadow:
        inset 0 0 0 1px rgba(15,23,42,0.8),
        0 18px 40px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    /* スマホ時は縦長に */
    @media (max-width: 600px) {
      .map {
        padding-bottom: 500%;
      }
    }

    .map::before {
      content: "";
      position: absolute;
      inset: 10% 6%;
      background-image: radial-gradient(circle, rgba(148,163,184,0.16) 1px, transparent 1px);
      background-size: 30px 30px;
      opacity: 0.35;
      pointer-events: none;
      z-index: 0;
    }

    .map-lines {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }
    .map-line {
      fill: none;
      stroke: rgba(34,197,94,0.85);
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.75));
    }

    .node {
      position: absolute;
      transform: translate(-50%, -50%);
      min-width: 80px;
      text-align: center;
      z-index: 3;
    }
    .node.locked {
      cursor: default;
    }
    .node.unlocked,
    .node.completed {
      cursor: pointer;
    }

    .node-circle {
      width: 72px;
      height: 72px;
      margin: 0 auto 6px;
      border-radius: 999px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 18px;
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        background 0.12s ease,
        color 0.12s ease;
      box-shadow: 0 4px 0 rgba(15,23,42,0.9);
    }

    .node.locked .node-circle {
      background: #0b1220;
      color: #4b5563;
      box-shadow: 0 3px 0 rgba(15,23,42,0.9);
      border: 1px solid #111827;
    }
    .node.unlocked .node-circle {
      background: #22c55e;
      color: #052e16;
      box-shadow:
        0 4px 0 rgba(15,23,42,0.9),
        0 0 0 4px rgba(34,197,94,0.25);
    }
    .node.completed .node-circle {
      background: #16a34a;
      color: #ecfdf3;
      box-shadow:
        0 5px 0 rgba(15,23,42,0.9),
        0 0 0 5px rgba(22,163,74,0.35);
      transform: translateY(-1px) scale(1.03);
    }
    .node.unlocked:hover .node-circle,
    .node.completed:hover .node-circle {
      transform: translateY(-2px) scale(1.04);
      box-shadow:
        0 7px 14px rgba(0,0,0,0.9),
        0 0 0 5px rgba(34,197,94,0.4);
    }

    .node-title {
      font-size: 16px;
      margin-bottom: 2px;
      color: #e5e7eb;
    }
    .node-progress {
      font-size: 9px;
      color: #9ca3af;
    }

    @media (max-width: 600px) {
      .node-title {
      font-size: 12px;
    }
    }
    
    /* 「よくできました！」トースト */
    .success-toast {
      position: absolute;
      left: 50%;
      top: 16%;
      transform: translate(-50%, -50%) scale(0.7);
      background: #22c55e;
      color: #022c22;
      font-size: 13px;
      font-weight: 700;
      padding: 6px 18px;
      border-radius: 999px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.75);
      pointer-events: none;
      opacity: 0;
      z-index: 5;
    }
    .success-toast.show {
      animation: success-pop 0.9s ease-out forwards;
    }
    @keyframes success-pop {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.6);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.05);
      }
      60% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
    }
        /* 紙吹雪 */
    .confetti {
      position: absolute;
      width: 6px;
      height: 10px;
      border-radius: 2px;
      opacity: 0;
      pointer-events: none;
      z-index: 4;
      animation: confetti-fall 900ms ease-out forwards;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 0;
        transform: translate3d(0, 0, 0) rotateZ(0deg);
      }
      10% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translate3d(var(--dx, 60px), 220px, 0) rotateZ(360deg);
      }
    }
    
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div class="top-bar-left">
        <h1>原稿すごろくマップ</h1>
        <div class="top-bar-info">
          一番上のマスから順番にクリックして進めていく原稿すごろくです。
        </div>
      </div>
      <div class="top-bar-right">
        <div class="streak-box">
          <div class="streak-label">現在の連続日数</div>
          <div class="streak-value" id="streakValue">0 日</div>
          <div class="streak-note">※朝5時区切りでカウント</div>
        </div>
        <button class="reset-btn" id="resetProgressBtn">進捗・連続日数をリセット</button>
      </div>
    </div>

    <!-- ページ切り替え -->
    <div class="page-nav">
      <button id="prevPageBtn">◀</button>
      <span id="pageLabel" class="page-nav-label">1ページ目 / 全1ページ</span>
      <button id="nextPageBtn">▶</button>
      <button id="addPageBtn">＋</button>
    </div>

    <div class="board-wrapper">
      <div id="map" class="map"></div>
      <div id="successToast" class="success-toast">よくできました！</div>
    </div>
  </div>

  <script>
    // ===== マス定義 =====
    const frameCount   = 6;
    const roughCount   = 6;
    const textCount    = 6;
    const penCount     = 6;
    const betaCount    = 6;
    const toneCount    = 6;
    const finishCount  = 6;

    const LESSONS = [];

    function addGroup(prefix, label, descBase, count, prevId) {
      let lastId = prevId;
      for (let i = 1; i <= count; i++) {
        const id = `${prefix}${i}`;
        const title = `${label}${i}コマ目`;
        LESSONS.push({
          id,
          title,
          description: descBase.replace("{n}", i),
          maxProgress: 1,
          prereqId: lastId
        });
        lastId = id;
      }
      return lastId;
    }

    let last = null;
    last = addGroup("frame_",  "枠線",   "枠線 {n}コマ目。",      frameCount, last);
    last = addGroup("rough_",  "下書き", "下書き {n}コマ目。",    roughCount, last);
    last = addGroup("text_",   "台詞",   "台詞 {n}コマ目。",      textCount,  last);
    last = addGroup("pen_",    "ペン入れ", "ペン入れ {n}コマ目。", penCount,   last);
    last = addGroup("beta_",   "ベタ",     "ベタ {n}コマ目。",     betaCount,  last);
    last = addGroup("tone_",   "トーン",   "トーン {n}コマ目。",   toneCount,  last);
    last = addGroup("finish_", "仕上げ",   "仕上げ {n}コマ目。",   finishCount,last);

    // ===== ページ管理 =====
    let currentPage = 1;
    const STORAGE_KEY = "mangaLessonProgress_v8_pages";
    const STREAK_KEY  = "mangaLessonStreak_v1";

    function createInitialProgressMap() {
      const obj = {};
      for (const lesson of LESSONS) {
        obj[lesson.id] = 0;
      }
      return obj;
    }

    function createNewData() {
      return {
        maxPage: 1,
        pages: { "1": createInitialProgressMap() }
      };
    }

    function migrateLegacyProgress(legacyObj) {
      const base = createInitialProgressMap();
      for (const id of Object.keys(base)) {
        if (typeof legacyObj[id] === "number") {
          base[id] = legacyObj[id];
        }
      }
      return base;
    }

    function loadAllProgress() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const data = createNewData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
      try {
        const parsed = JSON.parse(raw);
        if (parsed && parsed.pages) {
          for (let p = 1; p <= (parsed.maxPage || 1); p++) {
            const key = String(p);
            if (!parsed.pages[key]) parsed.pages[key] = createInitialProgressMap();
            else {
              const base = createInitialProgressMap();
              const src = parsed.pages[key];
              for (const id of Object.keys(base)) {
                base[id] = typeof src[id] === "number" ? src[id] : 0;
              }
              parsed.pages[key] = base;
            }
          }
          return parsed;
        } else {
          const legacy = (parsed && typeof parsed === "object") ? parsed : {};
          const data = createNewData();
          data.pages["1"] = migrateLegacyProgress(legacy);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
          return data;
        }
      } catch {
        const data = createNewData();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
    }

    function saveAllProgress(data) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function loadPageProgress(page) {
      const data = loadAllProgress();
      const key = String(page);
      if (!data.pages[key]) {
        data.pages[key] = createInitialProgressMap();
        if (page > data.maxPage) data.maxPage = page;
        saveAllProgress(data);
      }
      return { data, progress: data.pages[key] };
    }

    function resetAllPagesProgress() {
      const data = loadAllProgress();
      for (let p = 1; p <= data.maxPage; p++) {
        data.pages[String(p)] = createInitialProgressMap();
      }
      saveAllProgress(data);
    }

    // ===== グリッド配置（レスポンシブ：PC=6列, 600px以下=3列） =====
    function getPerRow() {
      return window.innerWidth <= 600 ? 3 : 6;
    }

    function computeGridPositions(count, perRow) {
      const positions = [];
      const rows = Math.ceil(count / perRow);

      // 横方向：左右に少し余白
      let marginX;
      if (perRow === 3) {
        marginX = 12;
      } else {
        marginX = 8;
      }
      const usableX = 100 - marginX * 2;
      const stepX   = perRow > 1 ? usableX / (perRow - 1) : 0;

      // 縦方向
      let marginTop;
      let totalY;
      if (perRow === 3) {
        marginTop = 5;
        totalY    = 90;
      } else {
        marginTop = 8;
        totalY    = 70;
      }
      const rowStep = rows > 1 ? totalY / (rows - 1) : 0;

      for (let i = 0; i < count; i++) {
        const row = Math.floor(i / perRow);
        const indexInRow = i % perRow;
        const isEvenRow = (row % 2 === 0);
        const col = isEvenRow ? indexInRow : perRow - 1 - indexInRow;

        const x = marginX + stepX * col;
        const y = marginTop + rowStep * row;
        positions.push({ x, y });
      }
      return positions;
    }
    // ===== 日付（朝5時区切り） =====
    function getLogicalDateKey(date = new Date()) {
      const d = new Date(date.getTime());
      const hour = d.getHours();
      if (hour < 5) d.setDate(d.getDate() - 1);

      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function keyToDate(key) {
      const [y, m, d] = key.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function dateToKey(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    // ===== 連続日数 =====
    function loadStreakData() {
      const raw = localStorage.getItem(STREAK_KEY);
      if (!raw) return {};
      try {
        const obj = JSON.parse(raw);
        return obj && typeof obj === "object" ? obj : {};
      } catch {
        return {};
      }
    }

    function saveStreakData(data) {
      localStorage.setItem(STREAK_KEY, JSON.stringify(data));
    }

    function resetStreakData() {
      saveStreakData({});
    }

    function registerActivity() {
      const data = loadStreakData();
      const todayKey = getLogicalDateKey();
      if (!data[todayKey]) {
        data[todayKey] = true;
        saveStreakData(data);
      }
    }

    function calcCurrentStreak() {
      const data = loadStreakData();
      const keys = Object.keys(data);
      if (keys.length === 0) return 0;

      const set = new Set(keys);
      let streak = 0;
      let d = keyToDate(getLogicalDateKey());
      while (true) {
        const key = dateToKey(d);
        if (set.has(key)) {
          streak += 1;
          d.setDate(d.getDate() - 1);
        } else {
          break;
        }
      }
      return streak;
    }

    function updateStreakDisplay() {
      const el = document.getElementById("streakValue");
      if (!el) return;
      el.textContent = `${calcCurrentStreak()} 日`;
    }

    // ===== ページ表示更新 =====
    function updatePageLabel(dataOpt) {
      const labelEl = document.getElementById("pageLabel");
      const prevBtn = document.getElementById("prevPageBtn");
      const nextBtn = document.getElementById("nextPageBtn");
      const data = dataOpt || loadAllProgress();
      if (!labelEl) return;
      labelEl.textContent = `${currentPage}ページ目 / 全${data.maxPage}ページ`;
      if (prevBtn) prevBtn.disabled = currentPage <= 1;
      if (nextBtn) nextBtn.disabled = currentPage >= data.maxPage;
    }

    // ===== 成功エフェクト =====
    let audioCtx = null;

    function showSuccessEffect() {
      const toast = document.getElementById("successToast");
      if (!toast) return;
      toast.classList.remove("show");
      void toast.offsetWidth;
      toast.classList.add("show");
    }

// targetNode: 紙吹雪を出したい .node 要素（nullなら中央付近から）
function triggerConfetti(targetNode) {
  const mapEl = document.getElementById("map");
  if (!mapEl) return;

  const mapRect = mapEl.getBoundingClientRect();

  // 基準位置（%）を計算：node があればその中心、なければ中央あたり
  let baseXPercent = 50;
  let baseYPercent = 20;

  if (targetNode) {
    const nodeRect = targetNode.getBoundingClientRect();
    const centerX = (nodeRect.left + nodeRect.right) / 2 - mapRect.left;
    const centerY = (nodeRect.top + nodeRect.bottom) / 2 - mapRect.top;
    baseXPercent = (centerX / mapRect.width) * 100;
    baseYPercent = (centerY / mapRect.height) * 100;
  }

  const count = 45;
  const colors = ["#22c55e", "#facc15", "#38bdf8", "#f97316", "#a855f7"];

  for (let i = 0; i < count; i++) {
    const piece = document.createElement("div");
    piece.className = "confetti";

    // 基準位置の周囲 ±8% くらいでバラけさせる
    const offsetX = (Math.random() * 16) - 8; // -8〜+8
    piece.style.left = (baseXPercent + offsetX) + "%";
    piece.style.top  = baseYPercent + "%";

    // 飛ぶ方向と距離
    const angle = (Math.random() * Math.PI) - Math.PI / 2;
    const distance = 140 + Math.random() * 120;
    const dx = Math.cos(angle) * distance;
    piece.style.setProperty("--dx", dx + "px");

    piece.style.backgroundColor = colors[i % colors.length];
    piece.style.animationDelay = (Math.random() * 0.18) + "s";

    mapEl.appendChild(piece);

    setTimeout(() => {
      piece.remove();
    }, 1000);
  }
}
    
function playSuccessSound(isFinal) {
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    if (!audioCtx) audioCtx = new Ctx();
    const ctx = audioCtx;
    const now = ctx.currentTime;

    // 共通ヘルパー：単音を鳴らす
    function tone(freq, start, duration, volume, type = "sine") {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, start);
      gain.gain.setValueAtTime(0.0001, start);
      gain.gain.exponentialRampToValueAtTime(volume, start + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
      osc.connect(gain).connect(ctx.destination);
      osc.start(start);
      osc.stop(start + duration + 0.02);
    }

    // 共通ヘルパー：軽いノイズ
    function sparkleNoise(start, duration, volume) {
      const bufferSize = duration * ctx.sampleRate;
      const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.4;
      }
      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer;
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(volume, start);
      gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
      noise.connect(gain).connect(ctx.destination);
      noise.start(start);
      noise.stop(start + duration + 0.05);
    }

    if (!isFinal) {
      // ===== 通常のクリア音（軽め・以前よりちょっと豪華） =====
      // 高めのキラ音
      tone(1320, now, 0.25, 0.25, "sine");
      // チャイムっぽい和音
      tone(660,  now + 0.02, 0.35, 0.18, "triangle");
      tone(880,  now + 0.02, 0.35, 0.18, "triangle");
      // キラキラノイズ
      sparkleNoise(now, 0.25, 0.08);
      return;
    }

    // ===== 仕上げ6コマ目用：盛大クリア音 =====
    // 上昇アルペジオ C-E-G-C （短いメロディ）
    const base = 523.25; // C5 くらい
    const step = 0.12;
    tone(base,           now + 0.00, 0.4, 0.26, "triangle");           // C
    tone(base * 1.25,    now + step, 0.4, 0.24, "triangle");           // E
    tone(base * 1.5,     now + step*2, 0.4, 0.22, "triangle");         // G
    tone(base * 2,       now + step*3, 0.5, 0.28, "sine");             // 高いC

    // 下で軽く支えるベース音
    tone(261.63, now, 0.6, 0.20, "sine");

    // キラキラノイズを少し長めに
    sparkleNoise(now, 0.45, 0.12);

  } catch (e) {
    console.warn("audio error", e);
  }
}
    // ===== レッスン状態 =====
    function isLessonUnlocked(lesson, progress) {
      if (!lesson.prereqId) return true;
      const prereq = LESSONS.find(l => l.id === lesson.prereqId);
      if (!prereq) return true;
      return progress[prereq.id] >= prereq.maxProgress;
    }

    function isLessonCompleted(lesson, progress) {
      return progress[lesson.id] >= lesson.maxProgress;
    }

function advanceLesson(lessonId) {
  const { data, progress } = loadPageProgress(currentPage);
  const lesson = LESSONS.find(l => l.id === lessonId);
  if (!lesson) return;

  if (!isLessonUnlocked(lesson, progress)) {
    logMessage(`「${lesson.title}」はまだ先のマスです。手前のマスから順番に進めてください。`);
    return;
  }
  if (progress[lesson.id] >= lesson.maxProgress) {
    logMessage(`「${lesson.title}」は既にクリアしています。`);
    return;
  }

  // 進捗更新
  progress[lesson.id] += 1;
  saveAllProgress(data);

  logMessage(`「${lesson.title}」をクリアしました。（${currentPage}ページ目）`);
  registerActivity();
  updateStreakDisplay();

  const isFinal = lesson.id === "finish_6";

  // 先にマップを描き直す（ここで node が描き直される）
  renderAll();

  // 描き直した後の DOM から、対象マスの要素を取り直す
  const mapEl = document.getElementById("map");
  const targetNode = mapEl
    ? mapEl.querySelector(`.node[data-lesson-id="${lessonId}"]`)
    : null;

  // 演出
  showSuccessEffect();
  triggerConfetti(targetNode);   // ← クリックしたマスの周りから紙吹雪
  playSuccessSound(isFinal);
}
    
    // ===== ログ（今はコンソール出力のみ） =====
    function logMessage(text) {
      console.log(text);
    }

    // ===== マップ描画 =====
    function renderMap(progress) {
      const mapEl = document.getElementById("map");
      mapEl.innerHTML = "";

      const perRow = getPerRow();
      const positions = computeGridPositions(LESSONS.length, perRow);

      LESSONS.forEach((lesson, index) => {
        const unlocked = isLessonUnlocked(lesson, progress);
        const completed = isLessonCompleted(lesson, progress);
        const pos = positions[index];

        const node = document.createElement("div");
        node.className = "node";
        node.dataset.lessonId = lesson.id;
        node.style.left = pos.x + "%";
        node.style.top = pos.y + "%";

        if (!unlocked) node.classList.add("locked");
        if (unlocked) node.classList.add("unlocked");
        if (completed) node.classList.add("completed");

        const circle = document.createElement("div");
        circle.className = "node-circle";
        circle.textContent = index + 1;

        const title = document.createElement("div");
        title.className = "node-title";
        title.textContent = lesson.title;

        const progressText = document.createElement("div");
        progressText.className = "node-progress";
        if (completed) {
          progressText.textContent = "クリア済み";
        } else if (unlocked) {
          progressText.textContent = "クリックして進む";
        } else {
          progressText.textContent = "ロック中";
        }

        node.appendChild(circle);
        node.appendChild(title);
        node.appendChild(progressText);

        node.addEventListener("click", () => advanceLesson(lesson.id));
        mapEl.appendChild(node);
      });

      requestAnimationFrame(drawLinesFromDom);
    }

    function drawLinesFromDom() {
      const mapEl = document.getElementById("map");
      if (!mapEl) return;

      const oldSvg = mapEl.querySelector(".map-lines");
      if (oldSvg) oldSvg.remove();

      const nodes = Array.from(mapEl.querySelectorAll(".node"));
      if (nodes.length < 2) return;

      const mapRect = mapEl.getBoundingClientRect();
      const centers = nodes.map(node => {
        const r = node.getBoundingClientRect();
        const cx = (r.left + r.right) / 2 - mapRect.left;
        const cy = (r.top + r.bottom) / 2 - mapRect.top;
        return { x: cx, y: cy };
      });

      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("class", "map-lines");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", `0 0 ${mapRect.width} ${mapRect.height}`);
      svg.setAttribute("preserveAspectRatio", "none");

      for (let i = 0; i < centers.length - 1; i++) {
        const p1 = centers[i];
        const p2 = centers[i + 1];
        const path = document.createElementNS(svgNS, "path");
        const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        path.setAttribute("d", d);
        path.setAttribute("class", "map-line");
        svg.appendChild(path);
      }

      mapEl.insertBefore(svg, mapEl.firstChild);
    }

    function renderAll() {
      const { data, progress } = loadPageProgress(currentPage);
      renderMap(progress);
      updateStreakDisplay();
      updatePageLabel(data);
    }

    window.addEventListener("DOMContentLoaded", () => {
      renderAll();

      document.getElementById("resetProgressBtn").addEventListener("click", () => {
        if (!confirm("本当に全ページの進捗と連続日数をリセットしますか？")) return;
        resetAllPagesProgress();
        resetStreakData();
        renderAll();
      });

      document.getElementById("prevPageBtn").addEventListener("click", () => {
        if (currentPage > 1) {
          currentPage--;
          renderAll();
        }
      });
      document.getElementById("nextPageBtn").addEventListener("click", () => {
        const data = loadAllProgress();
        if (currentPage < data.maxPage) {
          currentPage++;
          renderAll();
        }
      });
      document.getElementById("addPageBtn").addEventListener("click", () => {
        const data = loadAllProgress();
        const newPage = data.maxPage + 1;
        data.maxPage = newPage;
        data.pages[String(newPage)] = createInitialProgressMap();
        saveAllProgress(data);
        currentPage = newPage;
        logMessage(`${newPage}ページ目を追加しました。`);
        renderAll();
      });

      // 画面幅が変わったらレイアウト再計算
      window.addEventListener("resize", () => {
        renderAll();
      });
    });
  </script>
</body>
</html>
