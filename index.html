<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>原稿マップ・すごろく</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 4px;
    }
    .app-container {
      max-width: 960px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      padding: 16px;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: stretch;
      margin-bottom: 16px;
      gap: 8px;
      flex-wrap: wrap;
    }
    .top-bar-left {
      flex: 1 1 auto;
      min-width: 180px;
    }
    .top-bar-info {
      font-size: 13px;
      color: #555;
    }
    .top-bar-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      flex: 0 0 auto;
      min-width: 160px;
    }
    .streak-box {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 11px;
      background: #fafafa;
      text-align: right;
    }
    .streak-label {
      color: #555;
      margin-bottom: 2px;
    }
    .streak-value {
      font-size: 16px;
      font-weight: bold;
      color: #c56;
    }
    .streak-note {
      color: #888;
      font-size: 10px;
      margin-top: 2px;
    }
    .reset-btn {
      border: 1px solid #d33;
      background: #fff5f5;
      color: #b00;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      align-self: flex-end;
    }
    .reset-btn:hover {
      background: #ffe5e5;
    }
    .board-wrapper {
      margin-bottom: 16px;
    }
    .map {
      position: relative;
      width: 100%;
      padding-bottom: 60%;
      border-radius: 12px;
      background:
        radial-gradient(circle at 10% 20%, #fef9e7 0, #fef9e7 40%, transparent 41%),
        radial-gradient(circle at 80% 70%, #e8f9ff 0, #e8f9ff 35%, transparent 36%),
        #fdfdfd;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    .map::before {
      content: "";
      position: absolute;
      inset: 8% 4%;
      background-image: radial-gradient(circle, rgba(255,150,120,0.6) 2px, transparent 2px);
      background-size: 32px 32px;
      opacity: 0.25;
      pointer-events: none;
      z-index: 0;
    }
    .map-lines {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }
    .map-line {
      fill: none;
      stroke: rgba(255, 152, 0, 0.7);
      stroke-width: 4;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .node {
      position: absolute;
      transform: translate(-50%, -50%);
      min-width: 80px;
      text-align: center;
      z-index: 3;
    }
    .node.locked {
      cursor: not-allowed;
    }
    .node.unlocked,
    .node.completed {
      cursor: pointer;
    }
    .node-circle {
      width: 64px;
      height: 64px;
      margin: 0 auto 6px;
      border-radius: 50%;
      border: 2px solid #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fefefe;
      font-weight: bold;
      font-size: 16px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.1s ease, background 0.1s ease;
    }
    .node.locked .node-circle {
      background: #f0f0f0;
      border-style: dashed;
      color: #aaa;
    }
    .node.unlocked .node-circle {
      border-color: #36a;
      background: #ffffff;
    }
    .node.completed .node-circle {
      background: #36a;
      border-color: #247;
      color: #fff;
      box-shadow: 0 0 0 3px rgba(54,106,170,0.25);
    }
    .node.unlocked:hover .node-circle,
    .node.completed:hover .node-circle {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .node-title {
      font-size: 11px;
      margin-bottom: 2px;
    }
    .node-progress {
      font-size: 10px;
      color: #555;
    }
    .label-start,
    .label-goal {
      position: absolute;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: bold;
      color: #fff;
      z-index: 4;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }
    .label-start {
      background: #4caf50;
    }
    .label-goal {
      background: #ff9800;
    }
    .log-panel {
      border-top: 1px solid #eee;
      padding-top: 8px;
      margin-top: 8px;
    }
    .log-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .log {
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 4px 6px;
      background: #fcfcfc;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    .empty-log {
      color: #999;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div class="top-bar-left">
        <h1>原稿すごろくマップ</h1>
        <div class="top-bar-info">
          一番上のマスから順番にクリックして進めていく原稿すごろくです。
        </div>
      </div>
      <div class="top-bar-right">
        <div class="streak-box">
          <div class="streak-label">現在の連続日数</div>
          <div class="streak-value" id="streakValue">0 日</div>
          <div class="streak-note">※朝5時区切りでカウント</div>
        </div>
        <button class="reset-btn" id="resetProgressBtn">進捗・連続日数をリセット</button>
      </div>
    </div>

    <div class="board-wrapper">
      <div id="map" class="map"></div>
    </div>

    <div class="log-panel">
      <div class="log-title">アクションログ</div>
      <div id="log" class="log empty-log">まだ何も進んでいません。</div>
      <div style="font-size:11px; color:#888; margin-top:4px;">
        どのマスまで進んだかのメモとして使えます。
      </div>
    </div>
  </div>

  <script>
    // ===== マス定義 =====
    const frameCount   = 6; // 枠線
    const roughCount   = 6; // 下書き
    const textCount    = 6; // 台詞
    const penCount     = 6; // ペン入れ
    const betaCount    = 6; // ベタ
    const toneCount    = 6; // トーン
    const finishCount  = 6; // 仕上げ

    const LESSONS = [];

    // prefix: 保存ID用
    // label:  表示用の「枠線」「台詞」など（タイトルは「枠線1コマ目」のようになる）
    // descBase: 説明文テンプレ（{n} が 1,2,3…に置き換わる）
    function addGroup(prefix, label, descBase, count, prevId) {
      let lastId = prevId;
      for (let i = 1; i <= count; i++) {
        const id = `${prefix}${i}`;
        const title = `${label}${i}コマ目`;
        LESSONS.push({
          id,
          title,
          description: descBase.replace("{n}", i),
          maxProgress: 1,
          prereqId: lastId
        });
        lastId = id;
      }
      return lastId;
    }

    let last = null;
    // 枠線1〜6コマ目
    last = addGroup("frame_",  "枠線",   "枠線 {n}コマ目。",      frameCount, last);
    // 下書き1〜6コマ目
    last = addGroup("rough_",  "下書き", "下書き {n}コマ目。",    roughCount, last);
    // 台詞1〜6コマ目
    last = addGroup("text_",   "台詞",   "台詞 {n}コマ目。",      textCount,  last);
    // 台詞6コマ目の後に追加する4工程
    last = addGroup("pen_",    "ペン入れ", "ペン入れ {n}コマ目。", penCount,   last);
    last = addGroup("beta_",   "ベタ",     "ベタ {n}コマ目。",     betaCount,  last);
    last = addGroup("tone_",   "トーン",   "トーン {n}コマ目。",   toneCount,  last);
    last = addGroup("finish_", "仕上げ",   "仕上げ {n}コマ目。",   finishCount,last);

    const STORAGE_KEY = "mangaLessonProgress_v5_grid_lines_px";
    const STREAK_KEY  = "mangaLessonStreak_v1";

    // ===== グリッド配置（6個ごとに蛇行） =====
    const PER_ROW = 6;

    function computeGridPositions(count) {
      const positions = [];
      const rows = Math.ceil(count / PER_ROW);

      const marginX = 8;
      const usableX = 84;
      const stepX = PER_ROW > 1 ? usableX / (PER_ROW - 1) : 0;

      const marginTop = 12;
      const totalY = 200;
      const rowStep = rows > 1 ? totalY / (rows - 1) : 0;

      for (let i = 0; i < count; i++) {
        const row = Math.floor(i / PER_ROW);
        const indexInRow = i % PER_ROW;
        const isEvenRow = (row % 2 === 0);
        const col = isEvenRow ? indexInRow : PER_ROW - 1 - indexInRow;

        const x = marginX + stepX * col;
        const y = marginTop + rowStep * row;
        positions.push({ x, y });
      }
      return positions;
    }

    const NODE_POSITIONS = computeGridPositions(LESSONS.length);

    // ===== 日付（朝5時区切り） =====
    function getLogicalDateKey(date = new Date()) {
      const d = new Date(date.getTime());
      const hour = d.getHours();
      if (hour < 5) d.setDate(d.getDate() - 1);

      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function keyToDate(key) {
      const [y, m, d] = key.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function dateToKey(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    // ===== 進捗 =====
    function loadProgress() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        const init = {};
        for (const lesson of LESSONS) init[lesson.id] = 0;
        return init;
      }
      try {
        const parsed = JSON.parse(raw);
        for (const lesson of LESSONS) {
          if (typeof parsed[lesson.id] !== "number") parsed[lesson.id] = 0;
        }
        return parsed;
      } catch {
        const init = {};
        for (const lesson of LESSONS) init[lesson.id] = 0;
        return init;
      }
    }

    function saveProgress(progress) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
    }

    function resetProgress() {
      const progress = {};
      for (const lesson of LESSONS) progress[lesson.id] = 0;
      saveProgress(progress);
      return progress;
    }

    // ===== 連続日数 =====
    function loadStreakData() {
      const raw = localStorage.getItem(STREAK_KEY);
      if (!raw) return {};
      try {
        const obj = JSON.parse(raw);
        return obj && typeof obj === "object" ? obj : {};
      } catch {
        return {};
      }
    }

    function saveStreakData(data) {
      localStorage.setItem(STREAK_KEY, JSON.stringify(data));
    }

    function resetStreakData() {
      saveStreakData({});
    }

    function registerActivity() {
      const data = loadStreakData();
      const todayKey = getLogicalDateKey();
      if (!data[todayKey]) {
        data[todayKey] = true;
        saveStreakData(data);
      }
    }

    function calcCurrentStreak() {
      const data = loadStreakData();
      const keys = Object.keys(data);
      if (keys.length === 0) return 0;

      const set = new Set(keys);
      let streak = 0;
      let d = keyToDate(getLogicalDateKey());
      while (true) {
        const key = dateToKey(d);
        if (set.has(key)) {
          streak += 1;
          d.setDate(d.getDate() - 1);
        } else {
          break;
        }
      }
      return streak;
    }

    function updateStreakDisplay() {
      const el = document.getElementById("streakValue");
      if (!el) return;
      el.textContent = `${calcCurrentStreak()} 日`;
    }

    // ===== レッスン状態 =====
    function isLessonUnlocked(lesson, progress) {
      if (!lesson.prereqId) return true;
      const prereq = LESSONS.find(l => l.id === lesson.prereqId);
      if (!prereq) return true;
      return progress[prereq.id] >= prereq.maxProgress;
    }

    function isLessonCompleted(lesson, progress) {
      return progress[lesson.id] >= lesson.maxProgress;
    }

    function advanceLesson(lessonId) {
      const progress = loadProgress();
      const lesson = LESSONS.find(l => l.id === lessonId);
      if (!lesson) return;

      if (!isLessonUnlocked(lesson, progress)) {
        logMessage(`「${lesson.title}」はまだ先のマスです。手前のマスから順番に進めてください。`);
        return;
      }
      if (progress[lesson.id] >= lesson.maxProgress) {
        logMessage(`「${lesson.title}」は既にクリアしています。`);
        return;
      }

      progress[lesson.id] += 1;
      saveProgress(progress);
      logMessage(`「${lesson.title}」をクリアしました。`);
      registerActivity();
      updateStreakDisplay();
      renderAll();
    }

    // ===== ログ =====
    function logMessage(text) {
      const logEl = document.getElementById("log");
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      const prefix = `[${hh}:${mm}] `;

      if (logEl.classList.contains("empty-log")) {
        logEl.textContent = prefix + text;
        logEl.classList.remove("empty-log");
      } else {
        logEl.textContent += "\n" + prefix + text;
      }
      logEl.scrollTop = logEl.scrollHeight;
    }

    // ===== マップ描画 =====
    function renderMap(progress) {
      const mapEl = document.getElementById("map");
      mapEl.innerHTML = "";

      // マス本体
      LESSONS.forEach((lesson, index) => {
        const unlocked = isLessonUnlocked(lesson, progress);
        const completed = isLessonCompleted(lesson, progress);
        const pos = NODE_POSITIONS[index];

        const node = document.createElement("div");
        node.className = "node";
        node.dataset.lessonId = lesson.id;
        node.style.left = pos.x + "%";
        node.style.top = pos.y + "%";

        if (!unlocked) node.classList.add("locked");
        if (unlocked) node.classList.add("unlocked");
        if (completed) node.classList.add("completed");

        const circle = document.createElement("div");
        circle.className = "node-circle";
        circle.textContent = index + 1;

        const title = document.createElement("div");
        title.className = "node-title";
        title.textContent = lesson.title;

        const progressText = document.createElement("div");
        progressText.className = "node-progress";
        if (completed) {
          progressText.textContent = "クリア済み";
        } else if (unlocked) {
          progressText.textContent = "クリックして進む";
        } else {
          progressText.textContent = "ロック中";
        }

        node.appendChild(circle);
        node.appendChild(title);
        node.appendChild(progressText);

        node.addEventListener("click", () => advanceLesson(lesson.id));
        mapEl.appendChild(node);
      });

      // マスを置き終わったあとに線を引く
      requestAnimationFrame(drawLinesFromDom);
    }

    // 実際の DOM の位置から線を描画（px ベース）
    function drawLinesFromDom() {
      const mapEl = document.getElementById("map");
      if (!mapEl) return;

      const oldSvg = mapEl.querySelector(".map-lines");
      if (oldSvg) oldSvg.remove();

      const nodes = Array.from(mapEl.querySelectorAll(".node"));
      if (nodes.length < 2) return;

      const mapRect = mapEl.getBoundingClientRect();
      const centers = nodes.map(node => {
        const r = node.getBoundingClientRect();
        const cx = (r.left + r.right) / 2 - mapRect.left;
        const cy = (r.top + r.bottom) / 2 - mapRect.top;
        return { x: cx, y: cy };
      });

      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("class", "map-lines");
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.setAttribute("viewBox", `0 0 ${mapRect.width} ${mapRect.height}`);
      svg.setAttribute("preserveAspectRatio", "none");

      for (let i = 0; i < centers.length - 1; i++) {
        const p1 = centers[i];
        const p2 = centers[i + 1];
        const path = document.createElementNS(svgNS, "path");
        const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        path.setAttribute("d", d);
        path.setAttribute("class", "map-line");
        svg.appendChild(path);
      }

      mapEl.insertBefore(svg, mapEl.firstChild);
    }

    function renderAll() {
      const progress = loadProgress();
      renderMap(progress);
      updateStreakDisplay();
    }

    window.addEventListener("DOMContentLoaded", () => {
      renderAll();

      document.getElementById("resetProgressBtn").addEventListener("click", () => {
        if (!confirm("本当に進捗と連続日数をリセットしますか？")) return;
        resetProgress();
        resetStreakData();
        renderAll();

        const logEl = document.getElementById("log");
        logEl.textContent = "進捗と連続日数をリセットしました。";
        logEl.classList.add("empty-log");
      });

      // ウィンドウサイズ変更時も線を引き直す
      window.addEventListener("resize", () => {
        requestAnimationFrame(drawLinesFromDom);
      });
    });
  </script>
</body>
</html>
