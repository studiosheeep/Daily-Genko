<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>åŸç¨¿ãƒãƒƒãƒ—</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- favicon 404 å¯¾ç­– -->
  <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' fill='%2322c55e'/%3E%3C/svg%3E">

  <style>
:root {
  color-scheme: light;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  margin: 0;
  padding: 16px;
  background: #ffffff;
  color: #111827;
}

h1 {
  font-size: 20px;
  margin: 0 0 4px;
  color: #111827;
}

.app-container {
  max-width: 960px;
  margin: 0 auto;
  background: #ffffff;
  border-radius: 24px;
  padding: 18px 16px 20px;
}

/* ===== ä¸Šéƒ¨ãƒãƒ¼ ===== */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
  margin-bottom: 16px;
  padding: 10px 16px;
  background: linear-gradient(135deg, #22c55e, #16a34a);
  border-radius: 20px;
  color: #fff;
}

.top-bar-left {
  flex: 1 1 auto;
  min-width: 180px;
}

.top-bar-left h1#nextTaskTitle {
  font-size: 18px;
  font-weight: 800;
  margin: 0 0 2px;
  color: #fff;
}

.top-bar-info {
  font-size: 12px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
}

.top-bar-right {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 10px;
  flex: 0 0 auto;
}

@media (max-width: 600px) {
  .top-bar {
    flex-direction: column;
    align-items: stretch;
  }
  .top-bar-right {
    justify-content: flex-end;
    align-self: stretch;
  }
}

.streak-box {
  border-radius: 14px;
  padding: 6px 10px;
  font-size: 10px;
  background: rgba(0, 0, 0, 0.15);
  border: 1px solid rgba(255, 255, 255, 0.3);
  text-align: right;
  box-shadow: none;
}

.streak-label {
  color: rgba(255, 255, 255, 0.85);
  margin-bottom: 1px;
}

.streak-value {
  font-size: 16px;
  font-weight: 800;
  color: #fef9c3;
}

.streak-note {
  color: rgba(255, 255, 255, 0.8);
  font-size: 9px;
  margin-top: 2px;
}

.reset-btn {
  border-radius: 999px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  background: rgba(255, 255, 255, 0.12);
  color: #ffffff;
  padding: 6px 14px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 3px 0 rgba(22, 101, 52, 0.7);
}

.reset-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.reset-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(22, 101, 52, 0.7);
}

/* ===== ãƒšãƒ¼ã‚¸ãƒŠãƒ“ ===== */
.page-nav {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 13px;
  color: #111827;
}

.page-nav button {
  border: 1px solid #d1d5db;
  background: #ffffff;
  border-radius: 999px;
  padding: 4px 12px;
  font-size: 12px;
  cursor: pointer;
  color: #111827;
  box-shadow: 0 2px 0 rgba(229,231,235,1);
}

.page-nav button:hover:not(:disabled) {
  background: #f3f4f6;
}

.page-nav button:active:not(:disabled) {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(209,213,219,1);
}

.page-nav button:disabled {
  opacity: 0.4;
  cursor: default;
  box-shadow: none;
}

.page-nav-label {
  min-width: 150px;
  text-align: center;
  font-weight: 500;
  color: #111827;
}

/* ãƒšãƒ¼ã‚¸å‰Šé™¤ãƒœã‚¿ãƒ³ */
.page-reset-btn {
  border: 1px solid #fecaca;
  background: #fef2f2;
  color: #b91c1c;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 12px;
  cursor: pointer;
  box-shadow: 0 2px 0 rgba(254,226,226,1);
}

.page-reset-btn:hover {
  background: #fee2e2;
}

.page-reset-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(254,202,202,1);
}

/* ===== ãƒãƒƒãƒ—ã‚¨ãƒªã‚¢ ===== */
.board-wrapper {
  margin-bottom: 4px;
  position: relative;
}

.map {
  position: relative;
  width: 100%;
  padding-bottom: 160%;
  border-radius: 20px;
  background:
    radial-gradient(circle at 20% 0%, rgba(56,189,248,0.12) 0, transparent 55%),
    radial-gradient(circle at 80% 90%, rgba(34,197,94,0.12) 0, transparent 55%),
    #ffffff;
  box-shadow:
    inset 0 0 0 1px rgba(209,213,219,1),
    0 12px 30px rgba(15,23,42,0.08);
  overflow: hidden;
}

@media (max-width: 600px) {
  .map {
    padding-bottom: 500%;
  }
}

.map::before {
  content: "";
  position: absolute;
  inset: 10% 6%;
  background-image: radial-gradient(circle, rgba(148,163,184,0.2) 1px, transparent 1px);
  background-size: 30px 30px;
  opacity: 0.6;
  pointer-events: none;
  z-index: 0;
}

.map-lines {
  position: absolute;
  inset: -20px 0;
  z-index: 1;
  pointer-events: none;
}

.map-line {
  fill: none;
  stroke: rgba(34,197,94,0.85);
  stroke-width: 10;
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* ===== ãƒã‚¹ ===== */
.node {
  position: absolute;
  transform: translate(-50%, -50%);
  min-width: 80px;
  text-align: center;
  z-index: 3;
}
.node.locked {
  cursor: default;
}
.node.unlocked,
.node.completed {
  cursor: pointer;
}

.node-circle {
  width: 72px;
  height: 72px;
  margin: 0 auto 6px;
  border-radius: 999px;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 18px;
  transition:
    transform 0.12s ease,
    box-shadow 0.12s ease,
    background 0.12s ease,
    color 0.12s ease;
  box-shadow: 0 4px 0 rgba(15,23,42,0.9);
  position: relative;
}

.node.locked .node-circle {
  background: #e5e7eb;
  color: #9ca3af;
  box-shadow: 0 3px 0 rgba(209,213,219,1);
  border: 1px solid #cbd5f5;
}

.node.unlocked .node-circle {
  background: #22c55e;
  color: #052e16;
  box-shadow:
    0 4px 0 rgba(15,23,42,0.9),
    0 0 0 4px rgba(34,197,94,0.25);
}

.node.completed .node-circle {
  background: #16a34a;
  color: #111827 !important;
  box-shadow:
    0 5px 0 rgba(15,23,42,0.9),
    0 0 0 5px rgba(22,163,74,0.35);
  transform: translateY(-1px) scale(1.03);
}

.node.unlocked:hover .node-circle,
.node.completed:hover .node-circle {
  transform: translateY(-2px) scale(1.04);
  box-shadow:
    0 7px 14px rgba(0,0,0,0.9),
    0 0 0 5px rgba(34,197,94,0.4);
}

/* ===== ãƒãƒ¼ãƒ‰ã®æ–‡å­—è‰² ===== */
.node-title {
  font-size: 16px;
  margin-bottom: 2px;
  color: #111827;
}

.node-progress {
  font-size: 9px;
  color: #6b7280;
}

@media (max-width: 600px) {
  .node-title {
    font-size: 12px;
  }
}

/* æ¬¡ã®ãƒã‚¹å¼·èª¿ */
.next-node .node-circle {
  color: #ffffff !important;
}
.next-node .node-circle::after {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: inherit;
  border: 3px solid rgba(190, 242, 100, 0.9);
  opacity: 0;
  transform: scale(0.9);
  pointer-events: none;
  animation: node-ring 1.4s ease-out infinite;
}

@keyframes node-ring {
  0% {
    opacity: 0;
    transform: scale(0.7);
  }
  25% {
    opacity: 1;
    transform: scale(1.02);
  }
  80% {
    opacity: 0;
    transform: scale(1.35);
  }
  100% {
    opacity: 0;
    transform: scale(1.4);
  }
}

/* ===== ã€Œã‚ˆãã§ãã¾ã—ãŸï¼ã€ãƒˆãƒ¼ã‚¹ãƒˆ ===== */
.success-toast {
  position: absolute;
  left: 50%;
  top: 16%;
  transform: translate(-50%, -50%) scale(0.7);
  background: #22c55e;
  color: #ffffff;
  font-size: 20px;
  font-weight: 800;
  padding: 12px 32px;
  border-radius: 999px;
  box-shadow: 0 16px 36px rgba(0,0,0,0.75);
  pointer-events: none;
  opacity: 0;
  z-index: 5;
}

.success-toast.show {
  animation: success-pop 0.9s ease-out forwards;
}

@keyframes success-pop {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.6);
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.12);
  }
  60% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
  }
}

.confetti {
  position: absolute;
  width: 6px;
  height: 10px;
  border-radius: 2px;
  opacity: 0;
  pointer-events: none;
  z-index: 4;
  animation: confetti-fall 900ms linear forwards;
}

@keyframes confetti-fall {
  0% {
    opacity: 0;
    transform: translate3d(0, 0, 0) rotateZ(0deg);
  }
  20% {
    opacity: 1;
    transform: translate3d(0, -80px, 0) rotateZ(120deg);
  }
  100% {
    opacity: 0;
    transform: translate3d(0, 260px, 0) rotateZ(360deg);
  }
}

/* ===== ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ« ===== */
.side-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 520px;
  max-width: 98vw;
  background: #ffffff;
  border-radius: 20px;
  border: 1px solid #e5e7eb;
  box-shadow: 0 24px 60px rgba(15,23,42,0.16);
  padding: 18px 20px 16px;
  font-size: 15px;
  opacity: 0;
  transform: translate(-50%, -48%) scale(0.94);
  pointer-events: none;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
  z-index: 30;
}

.side-panel.open {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
  pointer-events: auto;
}

.side-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.side-panel-header span {
  font-size: 18px;
  font-weight: 800;
  color: #0f172a;
}

.side-panel-close {
  background: transparent;
  border: none;
  color: #6b7280;
  font-size: 20px;
  cursor: pointer;
  padding: 2px 4px;
  line-height: 1;
}
.side-panel-close:hover {
  color: #111827;
}

.side-panel-body {
  font-size: 14px;
  color: #374151;
  line-height: 1.4;
}

/* èª¬æ˜æ–‡ç›´å¾Œã®ä½™ç™½ã‚’ã‚¼ãƒ­ã« */
.side-panel-body > div:first-child {
  margin-bottom: 0 !important;
}

/* ãƒ•ãƒƒã‚¿ãƒ¼ï¼ˆé€²ã‚ãŸï¼‹æ›¸ãå‡ºã™ï¼‰ */
.side-panel-footer {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 8px;
}

.side-panel-done-btn,
.side-panel-export-btn {
  border-radius: 999px;
  border: none;
  font-size: 13px;
  font-weight: 700;
  padding: 9px 16px;
  cursor: pointer;
  box-shadow: 0 3px 0 rgba(21,128,61,0.8);
}

.side-panel-done-btn {
  background: #22c55e;
  color: #ffffff;
}
.side-panel-done-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(21,128,61,0.8);
}

/* ãƒ™ã‚¿ã€œä»•ä¸Šã’æ™‚ã«ä½¿ç”¨ */
.side-panel-export-btn {
  display: none;
  background: #0ea5e9;
  color: #f9fafb;
  box-shadow: 0 3px 0 rgba(30,64,175,0.8);
}
.side-panel-export-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(30,64,175,0.8);
}

@media (max-width: 600px) {
  .side-panel {
    width: 100vw;
    max-width: 100vw;
    max-height: 92vh;
    box-sizing: border-box;
    padding: 10px 10px 12px;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
  }

  .side-panel-body {
    flex: 1 1 auto;
    overflow: auto;
  }
}

/* ã‚¹ãƒãƒ›ï¼ˆå¹…480pxä»¥ä¸‹ï¼‰ã¯ãƒ‘ãƒãƒ«ã‚’ã»ã¼å…¨ç”»é¢ã« */
@media (max-width: 480px) {
  .canvas-wrapper {
    width: 100%;
    max-height: 70vh;
    overflow: auto;
    border-radius: 8px;
  }

  .canvas-wrapper canvas {
    width: 100%;
    height: auto;
  }

  .side-panel-body {
    max-height: 80vh;
    overflow: auto;
  }
}

/* ===== åŸç¨¿ç”¨ç´™ã‚­ãƒ£ãƒ³ãƒã‚¹ ===== */
.canvas-wrapper {
  width: 100%;
  aspect-ratio: 4441 / 6213;          /* B5ç¸¦ã®æ¯”ç‡ */
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  background: #f9fafb;
  overflow: hidden;
  box-shadow: inset 0 0 0 1px rgba(148,163,184,0.25);
}

.canvas-wrapper canvas {
  width: 100%;
  height: 100%;
  display: block;
  touch-action: none; /* ãƒšãƒ³ã‚¿ãƒ–ãƒ»æŒ‡æç”»ã§èƒŒé¢ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãªã„ã‚ˆã†ã« */
}

/* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
.canvas-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: center;
  margin-top: 2px;
  margin-bottom: 4px;
  font-size: 12px;
  color: #4b5563;
}

.canvas-toolbar button {
  border-radius: 999px;
  border: 1px solid #d1d5db;
  background: #f9fafb;
  padding: 3px 10px;
  font-size: 11px;
  cursor: pointer;
  box-shadow: 0 2px 0 rgba(209,213,219,1);
}

.canvas-toolbar button:active {
  transform: translateY(1px);
  box-shadow: 0 1px 0 rgba(209,213,219,1);
}
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div class="top-bar-left">
        <h1 id="nextTaskTitle">åŸç¨¿ã™ã”ã‚ããƒãƒƒãƒ—</h1>
        <div class="top-bar-info" id="nextTaskInfo">
          ä¸€ç•ªä¸Šã®ãƒã‚¹ã‹ã‚‰é †ç•ªã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚ã¦ã„ãåŸç¨¿ã™ã”ã‚ãã§ã™ã€‚
        </div>
      </div>
      <div class="top-bar-right">
        <div class="streak-box">
          <div class="streak-label">ç¾åœ¨ã®é€£ç¶šæ—¥æ•°</div>
          <div class="streak-value" id="streakValue">0 æ—¥</div>
          <div class="streak-note">â€»æœ5æ™‚åŒºåˆ‡ã‚Šã§ã‚«ã‚¦ãƒ³ãƒˆ</div>
        </div>
        <button class="reset-btn" id="resetProgressBtn">é€²æ—ãƒ»é€£ç¶šæ—¥æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>

    <div class="page-nav">
      <button id="prevPageBtn">â—€</button>
      <span id="pageLabel" class="page-nav-label">1ãƒšãƒ¼ã‚¸ç›® / å…¨1ãƒšãƒ¼ã‚¸</span>
      <button id="nextPageBtn">â–¶</button>
      <button id="addPageBtn">ï¼‹</button>
      <button id="resetPagesBtn" class="page-reset-btn">ğŸ—‘</button>
    </div>

    <div class="board-wrapper">
      <div id="map" class="map"></div>
      <div id="successToast" class="success-toast">ã‚ˆãã§ãã¾ã—ãŸï¼</div>
    </div>
  </div>

  <!-- ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ« -->
  <div id="sidePanel" class="side-panel">
    <div class="side-panel-header">
      <div id="sidePanelTitle" class="side-panel-title"></div>
      <button id="sidePanelClose" class="side-panel-close">Ã—</button>
    </div>
    <div id="sidePanelBody" class="side-panel-body"></div>
    <div class="side-panel-footer">
      <button id="sidePanelDoneBtn" class="side-panel-done-btn">é€²ã‚ãŸ</button>
      <button id="sidePanelExportBtn" class="side-panel-export-btn">æ›¸ãå‡ºã™</button>
    </div>
  </div>

<script>
  /* ===== ã™ã”ã‚ãæ§‹æˆ ===== */
  const frameCount   = 6;
  const roughCount   = 6;
  const textCount    = 6;
  const penCount     = 6;
  const betaCount    = 6;
  const toneCount    = 6;
  const finishCount  = 6;

  const LESSONS = [];

  function addGroup(prefix, label, descBase, count, prevId) {
    let lastId = prevId;
    for (let i = 1; i <= count; i++) {
      const id = `${prefix}${i}`;
      const title = `${label}${i}ã‚³ãƒç›®`;
      LESSONS.push({
        id,
        title,
        description: descBase.replace("{n}", i),
        maxProgress: 1,
        prereqId: lastId
      });
      lastId = id;
    }
    return lastId;
  }

  let last = null;
  last = addGroup("frame_",  "æ ç·š",   "æ ç·š {n}ã‚³ãƒç›®ã€‚",      frameCount, last);
  last = addGroup("rough_",  "ä¸‹æ›¸ã", "ä¸‹æ›¸ã {n}ã‚³ãƒç›®ã€‚",    roughCount, last);
  last = addGroup("text_",   "å°è©",   "å°è© {n}ã‚³ãƒç›®ã€‚",      textCount,  last);
  last = addGroup("pen_",    "ãƒšãƒ³å…¥ã‚Œ", "ãƒšãƒ³å…¥ã‚Œ {n}ã‚³ãƒç›®ã€‚", penCount,   last);
  last = addGroup("beta_",   "ãƒ™ã‚¿",     "ãƒ™ã‚¿ {n}ã‚³ãƒç›®ã€‚",     betaCount,  last);
  last = addGroup("tone_",   "ãƒˆãƒ¼ãƒ³",   "ãƒˆãƒ¼ãƒ³ {n}ã‚³ãƒç›®ã€‚",   toneCount,  last);
  last = addGroup("finish_", "ä»•ä¸Šã’",   "ä»•ä¸Šã’ {n}ã‚³ãƒç›®ã€‚",   finishCount,last);

  let currentPage = 1;
  const STORAGE_KEY = "mangaLessonProgress_v8_pages";
  const STREAK_KEY  = "mangaLessonStreak_v1";

  /* ===== é€²æ—ä¿å­˜ ===== */
  function createInitialProgressMap() {
    const obj = {};
    for (const lesson of LESSONS) {
      obj[lesson.id] = 0;
    }
    return obj;
  }

  function createNewData() {
    return {
      maxPage: 1,
      pages: { "1": createInitialProgressMap() }
    };
  }

  function migrateLegacyProgress(legacyObj) {
    const base = createInitialProgressMap();
    for (const id of Object.keys(base)) {
      if (typeof legacyObj[id] === "number") {
        base[id] = legacyObj[id];
      }
    }
    return base;
  }

  function loadAllProgress() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      const data = createNewData();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      return data;
    }
    try {
      const parsed = JSON.parse(raw);
      if (parsed && parsed.pages) {
        for (let p = 1; p <= (parsed.maxPage || 1); p++) {
          const key = String(p);
          if (!parsed.pages[key]) parsed.pages[key] = createInitialProgressMap();
          else {
            const base = createInitialProgressMap();
            const src = parsed.pages[key];
            for (const id of Object.keys(base)) {
              base[id] = typeof src[id] === "number" ? src[id] : 0;
            }
            parsed.pages[key] = base;
          }
        }
        return parsed;
      } else {
        const legacy = (parsed && typeof parsed === "object") ? parsed : {};
        const data = createNewData();
        data.pages["1"] = migrateLegacyProgress(legacy);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        return data;
      }
    } catch {
      const data = createNewData();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      return data;
    }
  }

  function saveAllProgress(data) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function loadPageProgress(page) {
    const data = loadAllProgress();
    const key = String(page);
    if (!data.pages[key]) {
      data.pages[key] = createInitialProgressMap();
      if (page > data.maxPage) data.maxPage = page;
      saveAllProgress(data);
    }
    return { data, progress: data.pages[key] };
  }

  function resetAllPagesProgress() {
    const data = loadAllProgress();
    for (let p = 1; p <= data.maxPage; p++) {
      data.pages[String(p)] = createInitialProgressMap();
    }
    saveAllProgress(data);
  }

  function getPerRow() {
    return window.innerWidth <= 600 ? 3 : 6;
  }

  function computeGridPositions(count, perRow) {
    const positions = [];
    const rows = Math.ceil(count / perRow);

    let marginX = (perRow === 3) ? 12 : 8;
    const usableX = 100 - marginX * 2;
    const stepX   = perRow > 1 ? usableX / (perRow - 1) : 0;

    let marginTop, totalY;
    if (perRow === 3) {
      marginTop = 5;
      totalY    = 90;
    } else {
      marginTop = 8;
      totalY    = 70;
    }
    const rowStep = rows > 1 ? totalY / (rows - 1) : 0;

    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / perRow);
      const indexInRow = i % perRow;
      const isEvenRow = (row % 2 === 0);
      const col = isEvenRow ? indexInRow : perRow - 1 - indexInRow;

      const x = marginX + stepX * col;
      const y = marginTop + rowStep * row;
      positions.push({ x, y });
    }
    return positions;
  }

  /* ===== é€£ç¶šæ—¥æ•° ===== */
  function getLogicalDateKey(date = new Date()) {
    const d = new Date(date.getTime());
    const hour = d.getHours();
    if (hour < 5) d.setDate(d.getDate() - 1);
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }

  function keyToDate(key) {
    const [y, m, d] = key.split("-").map(Number);
    return new Date(y, m - 1, d);
  }

  function dateToKey(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  function loadStreakData() {
    const raw = localStorage.getItem(STREAK_KEY);
    if (!raw) return {};
    try {
      const obj = JSON.parse(raw);
      return obj && typeof obj === "object" ? obj : {};
    } catch {
      return {};
    }
  }

  function saveStreakData(data) {
    localStorage.setItem(STREAK_KEY, JSON.stringify(data));
  }

  function resetStreakData() {
    saveStreakData({});
  }

  function registerActivity() {
    const data = loadStreakData();
    const todayKey = getLogicalDateKey();
    if (!data[todayKey]) {
      data[todayKey] = true;
      saveStreakData(data);
    }
  }

  function calcCurrentStreak() {
    const data = loadStreakData();
    const keys = Object.keys(data);
    if (keys.length === 0) return 0;
    const set = new Set(keys);
    let streak = 0;
    let d = keyToDate(getLogicalDateKey());
    while (true) {
      const key = dateToKey(d);
      if (set.has(key)) {
        streak += 1;
        d.setDate(d.getDate() - 1);
      } else {
        break;
      }
    }
    return streak;
  }

  function updateStreakDisplay() {
    const el = document.getElementById("streakValue");
    if (!el) return;
    el.textContent = `${calcCurrentStreak()} æ—¥`;
  }

  /* ===== ãƒšãƒ¼ã‚¸ãƒ©ãƒ™ãƒ« ===== */
  function updatePageLabel(dataOpt) {
    const labelEl = document.getElementById("pageLabel");
    const prevBtn = document.getElementById("prevPageBtn");
    const nextBtn = document.getElementById("nextPageBtn");
    const data = dataOpt || loadAllProgress();
    if (!labelEl) return;
    labelEl.textContent = `${currentPage}ãƒšãƒ¼ã‚¸ç›® / å…¨${data.maxPage}ãƒšãƒ¼ã‚¸`;
    if (prevBtn) prevBtn.disabled = currentPage <= 1;
    if (nextBtn) nextBtn.disabled = currentPage >= data.maxPage;
  }

  // ===== æ¬¡ã®ã‚¿ã‚¹ã‚¯è¡¨ç¤º =====
  function getNextIncompleteLesson(progress) {
    let lastCompletedIndex = -1;
    LESSONS.forEach((lesson, index) => {
      if (isLessonCompleted(lesson, progress) && index > lastCompletedIndex) {
        lastCompletedIndex = index;
      }
    });

    for (let i = lastCompletedIndex + 1; i < LESSONS.length; i++) {
      const lesson = LESSONS[i];
      if (!isLessonCompleted(lesson, progress)) {
        return lesson;
      }
    }
    return null;
  }

  function updateNextTaskDisplay(progress) {
    const titleEl = document.getElementById("nextTaskTitle");
    const infoEl  = document.getElementById("nextTaskInfo");
    if (!titleEl || !infoEl) return;

    const next = getNextIncompleteLesson(progress);

    if (next) {
      titleEl.textContent = `${next.title}ã‚’é€²ã‚ã‚ˆã†ï¼`;
      infoEl.textContent  = `æ¬¡ã®ãƒã‚¹ã¯ã€Œ${next.title}ã€ã§ã™ã€‚ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚ã¦ã„ãã¾ã—ã‚‡ã†ã€‚`;
    } else {
      titleEl.textContent = "ã“ã®ãƒšãƒ¼ã‚¸ã¯å…¨éƒ¨ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼";
      infoEl.textContent  = "ãŠç–²ã‚Œã•ã¾ã§ã—ãŸã€‚æ–°ã—ã„ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ ã—ã¦ç¶šãã®åŸç¨¿ã‚’é€²ã‚ã¾ã—ã‚‡ã†ã€‚";
    }
  }

  /* ===== åŸç¨¿ç”¨ç´™æç”»ãƒ‡ãƒ¼ã‚¿ ===== */
  const EDIT_CANVAS_WIDTH  = 1000;
  const EDIT_CANVAS_HEIGHT = Math.round(EDIT_CANVAS_WIDTH * 6213 / 4441);
  const EXPORT_WIDTH  = 4961;
  const EXPORT_HEIGHT = 7016;
  const DRAW_STORAGE_KEY = "mangaBoardDraw_v1";

  const BALLOON_RX = 60;
  const BALLOON_RY = 80;

  /* ===== ãƒˆãƒ¼ãƒ³ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³(ç¶²ç‚¹) ===== */
  let tonePatternData = null;

  // 60ç·šç›¸å½“ï¼ˆ600dpiå‰æãƒ»45åº¦ãƒ»ç´„20ï¼…ï¼‰ã®ãƒˆãƒ¼ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
  function createTonePatternData() {
    // 600dpi / 60ç·š â‰’ 10pxé–“éš”
    // 20pxã‚¿ã‚¤ãƒ«ä¸­ã«å¯¾è§’ç·šä¸Šã«10pxé–“éš”ã§2ã¤ãƒ‰ãƒƒãƒˆã‚’ç½®ã
    const size = 20;
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");

    // ãƒ™ãƒ¼ã‚¹ã¯ç™½
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, size, size);

    // ãƒ‰ãƒƒãƒˆï¼ˆç¶²ç‚¹ï¼‰
    ctx.fillStyle = "#000000";
    const r = 3.6; // 2ã¤åˆ†ã§ãŠãŠã‚ˆã20ï¼…å¼±ã®æ¿ƒåº¦

    // å·¦ä¸Šå´ã®ç‚¹
    ctx.beginPath();
    ctx.arc(5, 5, r, 0, Math.PI * 2);
    ctx.fill();

    // å³ä¸‹å´ã®ç‚¹ï¼ˆ5+10=15ã§ç´„10pxé–“éš”ï¼‰
    ctx.beginPath();
    ctx.arc(15, 15, r, 0, Math.PI * 2);
    ctx.fill();

    const img = ctx.getImageData(0, 0, size, size);
    tonePatternData = {
      width: size,
      height: size,
      data: img.data
    };
  }

  function createEmptyDrawPage() {
    return {
      frames: {},
      rough: {},
      pen: {},
      text: {},
      beta: {},       // ãƒ™ã‚¿å¡—ã‚Šç”¨
      tone: {},       // ãƒˆãƒ¼ãƒ³å¡—ã‚Šç”¨
      roughColor: "black"
    };
  }

  function loadDrawAll() {
    const raw = localStorage.getItem(DRAW_STORAGE_KEY);
    if (!raw) return {};
    try {
      const obj = JSON.parse(raw);
      return obj && typeof obj === "object" ? obj : {};
    } catch {
      return {};
    }
  }

  function saveDrawAll(data) {
    localStorage.setItem(DRAW_STORAGE_KEY, JSON.stringify(data));
  }

  function getDrawPage(page) {
    const all = loadDrawAll();
    const key = String(page);
    if (!all[key]) {
      all[key] = createEmptyDrawPage();
    } else {
      const p = all[key];
      if (!p.frames) p.frames = {};
      if (!p.rough) p.rough = {};
      if (!p.pen)   p.pen   = {};
      if (!p.text)  p.text  = {};
      if (!p.beta)  p.beta  = {};
      if (!p.tone)  p.tone  = {};
      if (!p.roughColor) p.roughColor = "black";
    }
    saveDrawAll(all);
    return { all, pageData: all[key] };
  }

  function resetAllDrawData() {
    localStorage.removeItem(DRAW_STORAGE_KEY);
  }

  /* æç”»ä¸­ã®ãƒšãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦é«˜é€ŸåŒ– */
  let activeDrawPageData = null;

  /* ===== æˆåŠŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã© ===== */
  let audioCtx = null;

  function showSuccessEffect() {
    const toast = document.getElementById("successToast");
    if (!toast) return;
    toast.classList.remove("show");
    void toast.offsetWidth;
    toast.classList.add("show");
  }

  function triggerConfetti(targetNode) {
    const mapEl = document.getElementById("map");
    if (!mapEl) return;

    const mapRect = mapEl.getBoundingClientRect();

    let baseXPercent = 50;
    let baseYPercent = 20;

    if (targetNode) {
      const nodeRect = targetNode.getBoundingClientRect();
      const centerX = (nodeRect.left + nodeRect.right) / 2 - mapRect.left;
      const centerY = (nodeRect.top + nodeRect.bottom) / 2 - mapRect.top;
      baseXPercent = (centerX / mapRect.width) * 100;
      baseYPercent = (centerY / mapRect.height) * 100;
    }

    const count  = 45;
    const colors = ["#22c55e", "#facc15", "#38bdf8", "#f97316", "#a855f7"];

    for (let i = 0; i < count; i++) {
      const piece = document.createElement("div");
      piece.className = "confetti";

      const offsetX = (Math.random() * 30) - 15;
      piece.style.left = (baseXPercent + offsetX) + "%";
      piece.style.top  = baseYPercent + "%";

      piece.style.backgroundColor = colors[i % colors.length];
      piece.style.animationDelay  = (Math.random() * 0.18) + "s";

      mapEl.appendChild(piece);
      setTimeout(() => piece.remove(), 1000);
    }
  }

  function playSuccessSound(isFinal) {
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      if (!audioCtx) audioCtx = new Ctx();
      const ctx = audioCtx;
      const now = ctx.currentTime;

      function tone(freq, start, duration, volume, type = "sine") {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, start);
        gain.gain.setValueAtTime(0.0001, start);
        gain.gain.exponentialRampToValueAtTime(volume, start + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
        osc.connect(gain).connect(ctx.destination);
        osc.start(start);
        osc.stop(start + duration + 0.02);
      }

      function sparkleNoise(start, duration, volume) {
        const bufferSize = duration * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.4;
        }
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuffer;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(volume, start);
        gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
        noise.connect(gain).connect(ctx.destination);
        noise.start(start);
        noise.stop(start + duration + 0.05);
      }

      if (!isFinal) {
        tone(1320, now, 0.25, 0.25, "sine");
        tone(660,  now + 0.02, 0.35, 0.18, "triangle");
        tone(880,  now + 0.02, 0.35, 0.18, "triangle");
        sparkleNoise(now, 0.25, 0.08);
        return;
      }

      const base = 523.25;
      const step = 0.12;
      tone(base,           now + 0.00, 0.4, 0.26, "triangle");
      tone(base * 1.25,    now + step, 0.4, 0.24, "triangle");
      tone(base * 1.5,     now + step*2, 0.4, 0.22, "triangle");
      tone(base * 2,       now + step*3, 0.5, 0.28, "sine");

      tone(261.63, now, 0.6, 0.20, "sine");
      sparkleNoise(now, 0.45, 0.12);

    } catch (e) {
      console.warn("audio error", e);
    }
  }

  function isLessonUnlocked(lesson, progress) {
    return true;
  }

  function isLessonCompleted(lesson, progress) {
    return progress[lesson.id] >= lesson.maxProgress;
  }

  function logMessage(text) {
    console.log(text);
  }

  /* ===== åŸç¨¿ç”¨ç´™ãƒ™ãƒ¼ã‚¹ ===== */
  function drawPaperBase(ctx, w, h) {
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, w, h);

    ctx.strokeStyle = "#3b82f6";
    ctx.lineWidth = 1;

    const outerMargin = Math.min(w, h) * 0.04;
    const basicMargin = Math.min(w, h) * 0.12;
    const innerMargin = Math.min(w, h) * 0.18;

    ctx.strokeRect(
      outerMargin,
      outerMargin,
      w - outerMargin * 2,
      h - outerMargin * 2
    );

    ctx.strokeRect(
      basicMargin,
      basicMargin,
      w - basicMargin * 2,
      h - basicMargin * 2
    );

    ctx.strokeRect(
      innerMargin,
      innerMargin,
      w - innerMargin * 2,
      h - innerMargin * 2
    );

    const markLen = Math.min(w, h) * 0.03;
    const cornerLen = Math.min(w, h) * 0.025;

    const cx = w / 2;
    const cy = h / 2;

    ctx.beginPath();

    ctx.moveTo(cx, outerMargin - markLen);
    ctx.lineTo(cx, outerMargin);

    ctx.moveTo(cx, h - outerMargin);
    ctx.lineTo(cx, h - outerMargin + markLen);

    ctx.moveTo(outerMargin - markLen, cy);
    ctx.lineTo(outerMargin, cy);

    ctx.moveTo(w - outerMargin, cy);
    ctx.lineTo(w - outerMargin + markLen, cy);

    ctx.moveTo(outerMargin, outerMargin - cornerLen);
    ctx.lineTo(outerMargin, outerMargin);
    ctx.lineTo(outerMargin - cornerLen, outerMargin);

    ctx.moveTo(w - outerMargin, outerMargin - cornerLen);
    ctx.lineTo(w - outerMargin, outerMargin);
    ctx.lineTo(w - outerMargin + cornerLen, outerMargin);

    ctx.moveTo(outerMargin, h - outerMargin + cornerLen);
    ctx.lineTo(outerMargin, h - outerMargin);
    ctx.lineTo(outerMargin - cornerLen, h - outerMargin);

    ctx.moveTo(w - outerMargin, h - outerMargin + cornerLen);
    ctx.lineTo(w - outerMargin, h - outerMargin);
    ctx.lineTo(w - outerMargin + cornerLen, h - outerMargin);

    ctx.stroke();
    ctx.restore();
  }

  /* ===== ã€Œé€²ã‚ãŸã€å‡¦ç† ===== */
  function advanceLesson(lessonId) {
    const { data, progress } = loadPageProgress(currentPage);
    const lessonIndex = LESSONS.findIndex(l => l.id === lessonId);
    if (lessonIndex === -1) return;

    const lesson = LESSONS[lessonIndex];

    if (progress[lesson.id] >= lesson.maxProgress) {
      logMessage(`ã€Œ${lesson.title}ã€ã¯æ—¢ã«ã‚¯ãƒªã‚¢ã—ã¦ã„ã¾ã™ã€‚`);
      return;
    }

    progress[lesson.id] = lesson.maxProgress;

    for (let i = 0; i < lessonIndex; i++) {
      const prevLesson = LESSONS[i];
      if (progress[prevLesson.id] < prevLesson.maxProgress) {
        progress[prevLesson.id] = prevLesson.maxProgress;
      }
    }

    saveAllProgress(data);

    logMessage(`ã€Œ${lesson.title}ã€ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚ï¼ˆ${currentPage}ãƒšãƒ¼ã‚¸ç›®ï¼‰`);
    registerActivity();
    updateStreakDisplay();

    const isFinal = lesson.id === "finish_6";
    renderAll();

    const mapEl = document.getElementById("map");
    const targetNode = mapEl
      ? mapEl.querySelector(`.node[data-lesson-id="${lessonId}"]`)
      : null;

    showSuccessEffect();
    triggerConfetti(targetNode);
    playSuccessSound(isFinal);
  }

  /* ===== ã‚­ãƒ£ãƒ³ãƒã‚¹é–¢é€£ã‚°ãƒ­ãƒ¼ãƒãƒ« ===== */
  let pendingLessonId = null;
  let currentPanelMode = null;
  let currentPanelIndex = null;
  let drawingCanvas = null;
  let drawingCtx = null;
  let isDrawing = false;
  let lastX = 0, lastY = 0;
  let draggingBalloon = null;
  let selectedBalloon = null; // { panelIndex: number, balloonIndex: number } or null

  /* â˜… ã‚ºãƒ¼ãƒ ç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ« â˜… */
  let currentZoom = 1;
  let zoomMin = 1;
  let zoomMax = 3;

  /* â˜… ãƒ‘ãƒ³é–¢é€£ â˜… */
  let panX = 0;
  let panY = 0;
  let isPanning = false;
  let panStartClientX = 0;
  let panStartClientY = 0;
  let panStartX = 0;
  let panStartY = 0;

  /* â˜… ãƒ”ãƒ³ãƒç”¨ â˜… */
  let pinchBalloonIndex = null;
  let pinchStartDistance = null;
  let pinchStartZoom = 1;
  let pinchStartCenter = null;
  let pinchStartPanX = 0;
  let pinchStartPanY = 0;

  function applyCanvasZoom() {
    if (!drawingCanvas) return;
    drawingCanvas.style.transformOrigin = "center center";
    drawingCanvas.style.transform =
      `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
  }

  function resetZoomForMode() {
    if (currentPanelMode === "text") {
      zoomMin = 0.5;
      zoomMax = 3;
      currentZoom = 1;
    } else if (
      currentPanelMode === "rough" ||
      currentPanelMode === "pen"   ||
      currentPanelMode === "beta"  ||
      currentPanelMode === "tone"
    ) {
      zoomMin = 1;
      zoomMax = 3;
      currentZoom = 1;
    } else {
      zoomMin = 1;
      zoomMax = 1;
      currentZoom = 1;
    }

    panX = 0;
    panY = 0;

    applyCanvasZoom();
  }

  function clearCanvasListeners(canvas) {
    if (!canvas) return;
    canvas.onmousedown = canvas.onmousemove = canvas.onmouseup = canvas.onmouseleave = null;
    canvas.ontouchstart = canvas.ontouchmove = canvas.ontouchend = null;
    canvas.oncontextmenu = null;
    canvas.onpointerdown = canvas.onpointermove = canvas.onpointerup = canvas.onpointercancel = null;
  }

  function getPanelIndexFromLesson(lessonId) {
    const parts = lessonId.split("_");
    if (parts.length < 2) return null;
    const n = parseInt(parts[1], 10);
    return isNaN(n) ? null : n;
  }

function getStrokeWidth(evt, mode) {
  // pressure ã‚’ç„¡è¦–ã—ã¦ã»ã¼ä¸€å®šã®ç·šå¹…ã«ã™ã‚‹
  const base = mode === "pen" ? 3.0 : 2.0;
  return base;
}

function getCanvasPos(evt) {
  if (!drawingCanvas) return { x: 0, y: 0 };
  const canvas = drawingCanvas;

  // â˜… ãƒšãƒ³ã®å ´åˆã¯ offsetX ãŒæ­£å¸¸ã§ã¯ãªã„æ©Ÿç¨®ãŒå¤šã„
  const isPen = evt.pointerType === "pen";

  const canUseOffset =
    !isPen && !evt.touches && !evt.changedTouches &&
    typeof evt.offsetX === "number" &&
    typeof evt.offsetY === "number";

  if (canUseOffset) {
    const scaleX = canvas.width  / canvas.clientWidth;
    const scaleY = canvas.height / canvas.clientHeight;
    return {
      x: evt.offsetX * scaleX,
      y: evt.offsetY * scaleY
    };
  }

  // â˜… ã“ã“ã‹ã‚‰ä¸‹ã¯ rect åŸºæº–
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;

  if (evt.touches && evt.touches.length > 0) {
    clientX = evt.touches[0].clientX;
    clientY = evt.touches[0].clientY;
  } else if (evt.changedTouches && evt.changedTouches.length > 0) {
    clientX = evt.changedTouches[0].clientX;
    clientY = evt.changedTouches[0].clientY;
  } else {
    clientX = evt.clientX;
    clientY = evt.clientY;
  }

  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top)  * (canvas.height / rect.height);
  return { x, y };
}

  function normalizeRect(x1, y1, x2, y2) {
    const x = Math.min(x1, x2);
    const y = Math.min(y1, y2);
    const w = Math.abs(x2 - x1);
    const h = Math.abs(y2 - y1);
    return { x, y, w, h };
  }

  function pointInRect(x, y, rect) {
    return x >= rect.x && y >= rect.y && x <= rect.x + rect.w && y <= rect.y + rect.h;
  }

  function saveDrawPage(pageData) {
    const all = loadDrawAll();
    all[String(currentPage)] = pageData;
    saveDrawAll(all);
  }

  // ===== ãƒšãƒ³ç·šã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ï¼å…¥ã‚ŠæŠœã =====
  function smoothStrokePoints(pts) {
    if (!pts || pts.length <= 2) return pts || [];
    const res = [];
    for (let i = 0; i < pts.length; i++) {
      const p0 = pts[i - 1] || pts[i];
      const p1 = pts[i];
      const p2 = pts[i + 1] || pts[i];
      res.push({
        x: (p0.x + p1.x + p2.x) / 3,
        y: (p0.y + p1.y + p2.y) / 3,
        w: p1.w
      });
    }
    return res;
  }

  function taperFactor(i, n) {
    if (n <= 1) return 1;
    const t = i / (n - 1);
    const edge = 0.2;
    if (t < edge) return t / edge;
    if (t > 1 - edge) return (1 - t) / edge;
    return 1;
  }

  // å¹ãå‡ºã—ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
  function findBalloonAt(x, y) {
    const pageData = activeDrawPageData;
    if (!pageData || !pageData.text) return -1;
    const arr = pageData.text[currentPanelIndex] || [];
    for (let i = arr.length - 1; i >= 0; i--) {
      const b = arr[i];
      const scaleB = b.scale || 1;
      const rx = BALLOON_RX * scaleB;
      const ry = BALLOON_RY * scaleB;
      const dx = x - b.x;
      const dy = y - b.y;
      const v = (dx*dx)/(rx*rx) + (dy*dy)/(ry*ry);
      if (v <= 1) return i;
    }
    return -1;
  }

  function measureBalloonSize(text, fontSize) {
    const lineTexts = String(text).split(/[\/\n]/);
    const columns = lineTexts.map(line => Array.from(line));

    let maxLen = 0;
    columns.forEach(chars => {
      if (chars.length > maxLen) maxLen = chars.length;
    });

    const lineHeight = fontSize * 1.1;
    const colWidth   = fontSize + 4;

    const textHeight = lineHeight * maxLen;
    const textWidth  = colWidth * columns.length;

    const padding = fontSize * 1.2;

    return {
      rx: textWidth  / 2 + padding,
      ry: textHeight / 2 + padding
    };
  }

  // å¥èª­ç‚¹ãƒ»ä¸‰ç‚¹ãƒªãƒ¼ãƒ€å°‚ç”¨ã®ç¸¦æ›¸ãæç”»
  function drawVerticalBalloonText(ctx, text, centerX, centerY) {
    const fontSize = 18;

    ctx.save();
    ctx.font =
      `${fontSize}px ` +
      `"ã‚„ã•ã—ã•ã‚¢ãƒ³ãƒãƒƒã‚¯","æ–°ã‚³ãƒŸãƒƒã‚¯ä½“","æºæšã‚¢ãƒ³ãƒãƒƒã‚¯","ãƒãƒãƒ³ãƒã‚«æº",` +
      `"Yu Mincho","Hiragino Mincho ProN",serif`;
    ctx.fillStyle = "#111827";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const lineTexts = String(text).split(/[\/\n]/);
    const columns = lineTexts.map(line => Array.from(line));

    let maxLen = 0;
    columns.forEach(chars => {
      if (chars.length > maxLen) maxLen = chars.length;
    });

    const lineHeight  = fontSize * 1.1;
    const totalHeight = lineHeight * (maxLen - 1);
    const topY        = centerY - totalHeight / 2;

    const colGap     = fontSize + 4;
    const totalWidth = colGap * (columns.length - 1);
    const rightX     = centerX + totalWidth / 2;

    columns.forEach((chars, colIndex) => {
      const x = rightX - colGap * colIndex;

      chars.forEach((ch, i) => {
        const baseY = topY + lineHeight * i;
        let drawX   = x;
        let drawY   = baseY;

        if (ch === "ã€" || ch === "ã€‚") {
          drawX = x - fontSize * 0.12;
          drawY = baseY + fontSize * 0.15;
          ctx.fillText(ch, drawX, drawY);
          return;
        }

        if (ch === "â€¦") {
          const dotGap = fontSize * 0.32;
          const r      = fontSize * 0.07;
          for (let k = -1; k <= 1; k++) {
            ctx.beginPath();
            ctx.arc(drawX, baseY + dotGap * k, r, 0, Math.PI * 2);
            ctx.fill();
          }
          return;
        }

        if (ch === "ãƒ¼" || ch === "ã€œ" || ch === "ï½") {
          ctx.save();
          ctx.translate(drawX, drawY);
          ctx.rotate(Math.PI / 2);
          ctx.fillText(ch, 0, 0);
          ctx.restore();
          return;
        }

        ctx.fillText(ch, drawX, baseY);
      });
    });

    ctx.restore();
  }

  function drawBalloonTail(ctx, b, rx, ry) {
    const side = b.tailSide === "right" ? "right" : "left";
    const dir  = side === "right" ? 1 : -1;

    const tCenter = 0.42;
    const tSpread = 0.07;

    function ellipseSidePoint(tOffset) {
      const y = b.y + ry * (tCenter + tOffset);
      const ny = (y - b.y) / ry;
      const dx = rx * Math.sqrt(1 - ny * ny);
      const x  = b.x + dir * dx;
      return { x, y };
    }

    const p1 = ellipseSidePoint(-tSpread);
    const p2 = ellipseSidePoint(+tSpread);

    const tipX = b.x + dir * (rx + 18);
    const tipY = b.y + ry * 0.50;

    ctx.save();

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(p2.x, p2.y);
    ctx.closePath();
    ctx.fillStyle = "#ffffff";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 4;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  /* ===== ãƒ™ã‚¿ç”¨å¡—ã‚Šã¤ã¶ã— ===== */
  function floodFillBeta(ctx, startX, startY, rect) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;

    const sx = Math.floor(startX);
    const sy = Math.floor(startY);

    if (!rect) return;

    const rx = Math.max(0, Math.floor(rect.x));
    const ry = Math.max(0, Math.floor(rect.y));
    const rw = Math.min(w - rx, Math.floor(rect.w));
    const rh = Math.min(h - ry, Math.floor(rect.h));

    if (
      sx < rx || sx >= rx + rw ||
      sy < ry || sy >= ry + rh
    ) {
      return;
    }

    const img = ctx.getImageData(0, 0, w, h);
    const data = img.data;

    function idx(x, y) {
      return (y * w + x) * 4;
    }

    const DARK_BOUNDARY = 200;

    function isFillable(i) {
      if (isBetaBlackPixel(data, i)) return false;

      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      const brightness = (r + g + b) / 3;

      return brightness >= DARK_BOUNDARY;
    }

    const stack = [[sx, sy]];

    while (stack.length) {
      const [x, y] = stack.pop();
      if (x < rx || x >= rx + rw || y < ry || y >= ry + rh) continue;
      const i = idx(x, y);
      if (!isFillable(i)) continue;

      data[i]     = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
      data[i + 3] = 255;

      stack.push([x + 1, y]);
      stack.push([x - 1, y]);
      stack.push([x, y + 1]);
      stack.push([x, y - 1]);
    }

    ctx.putImageData(img, 0, 0);

    expandBetaRegion(ctx, rect, 1);
  }

  function isBetaBlackPixel(data, index) {
    return (
      data[index]     === 0 &&
      data[index + 1] === 0 &&
      data[index + 2] === 0 &&
      data[index + 3] === 255
    );
  }

  function expandBetaRegion(ctx, rect, iterations = 1) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;

    const rx = Math.max(0, Math.floor(rect.x));
    const ry = Math.max(0, Math.floor(rect.y));
    const rw = Math.min(w - rx, Math.floor(rect.w));
    const rh = Math.min(h - ry, Math.floor(rect.h));

    function idx(x, y) {
      return (y * w + x) * 4;
    }

    const img = ctx.getImageData(0, 0, w, h);
    const data = img.data;

    for (let it = 0; it < iterations; it++) {
      const prev = new Uint8ClampedArray(data);

      for (let y = ry; y < ry + rh; y++) {
        for (let x = rx; x < rx + rw; x++) {
          const i = idx(x, y);
          if (isBetaBlackPixel(prev, i)) continue;

          let hasBlackNeighbor = false;
          for (let dy = -1; dy <= 1 && !hasBlackNeighbor; dy++) {
            for (let dx = -1; dx <= 1 && !hasBlackNeighbor; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx;
              const ny = y + dy;
              if (nx < rx || nx >= rx + rw || ny < ry || ny >= ry + rh) continue;
              const ni = idx(nx, ny);
              if (isBetaBlackPixel(prev, ni)) {
                hasBlackNeighbor = true;
              }
            }
          }

          if (hasBlackNeighbor) {
            data[i]     = 0;
            data[i + 1] = 0;
            data[i + 2] = 0;
            data[i + 3] = 255;
          }
        }
      }
    }

    ctx.putImageData(img, 0, 0);
  }

  function applyBetaFills(ctx, pageData) {
    if (!pageData || !pageData.beta) return;
    for (const [panelIndex, fills] of Object.entries(pageData.beta)) {
      const rect = pageData.frames[panelIndex];
      if (!rect) continue;
      const r = {
        x: rect.x,
        y: rect.y,
        w: rect.w,
        h: rect.h
      };
      fills.forEach(f => {
        floodFillBeta(ctx, f.x, f.y, r);
      });
    }
  }

  /* ===== ãƒˆãƒ¼ãƒ³ç”¨å¡—ã‚Šã¤ã¶ã—ï¼ˆç¶²ç‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ ===== */
  function applyToneFills(ctx, pageData) {
    if (!pageData || !pageData.tone) return;
    if (!tonePatternData) return;

    const w = ctx.canvas.width;
    const h = ctx.canvas.height;

    const baseImg = ctx.getImageData(0, 0, w, h);
    const baseData = baseImg.data;

    const outImg = ctx.getImageData(0, 0, w, h);
    const outData = outImg.data;

    const visited = new Uint8Array(w * h);

    const pW = tonePatternData.width;
    const pH = tonePatternData.height;
    const pData = tonePatternData.data;

    const DARK_BOUNDARY = 200;

    function floodPanel(panelIndex, seed) {
      const rect = pageData.frames[panelIndex];
      if (!rect) return;

      const rx = Math.max(0, Math.floor(rect.x));
      const ry = Math.max(0, Math.floor(rect.y));
      const rw = Math.min(w - rx, Math.floor(rect.w));
      const rh = Math.min(h - ry, Math.floor(rect.h));

      const sx = Math.floor(seed.x);
      const sy = Math.floor(seed.y);

      if (sx < rx || sx >= rx + rw || sy < ry || sy >= ry + rh) return;

      const stack = [[sx, sy]];

      while (stack.length) {
        const [x, y] = stack.pop();
        if (x < rx || x >= rx + rw || y < ry || y >= ry + rh) continue;

        const pos = y * w + x;
        if (visited[pos]) continue;
        visited[pos] = 1;

        const i = pos * 4;
        const r = baseData[i];
        const g = baseData[i + 1];
        const b = baseData[i + 2];
        const brightness = (r + g + b) / 3;

        if (brightness < DARK_BOUNDARY) continue;

        const tx = ((x % pW) + pW) % pW;
        const ty = ((y % pH) + pH) % pH;
        const ti = (ty * pW + tx) * 4;

        outData[i]     = pData[ti];
        outData[i + 1] = pData[ti + 1];
        outData[i + 2] = pData[ti + 2];
        outData[i + 3] = pData[ti + 3];

        stack.push([x + 1, y]);
        stack.push([x - 1, y]);
        stack.push([x, y + 1]);
        stack.push([x, y - 1]);
      }
    }

    for (const [panelIndex, fills] of Object.entries(pageData.tone)) {
      fills.forEach(f => floodPanel(panelIndex, f));
    }

    ctx.putImageData(outImg, 0, 0);
  }

  /* ===== ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»å…±é€š ===== */
  function drawStrokeLayerOnCtx(ctx, pageData, layerName, strokeStyle, defaultWidth, useVariableWidth) {
    const layer = pageData[layerName] || {};
    ctx.save();
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.strokeStyle = strokeStyle;

    for (const [panelIndex, paths] of Object.entries(layer)) {
      const rect = pageData.frames[panelIndex];
      if (rect) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
        ctx.clip();
      }

      paths.forEach(path => {
        let pts = path.points;
        if (!pts || pts.length < 2) return;

        if (useVariableWidth) {
          pts = smoothStrokePoints(pts);
        }

        const n = pts.length;

        if (!useVariableWidth) {
          ctx.lineWidth = defaultWidth;
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < n; i++) {
            ctx.lineTo(pts[i].x, pts[i].y);
          }
          ctx.stroke();
        } else {
          for (let i = 0; i < n - 1; i++) {
            const p0 = pts[i];
            const p1 = pts[i + 1];
            const baseW = p0.w != null ? p0.w : defaultWidth;
            const w = Math.max(0.5, baseW * taperFactor(i, n));
            ctx.lineWidth = w;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
          }
        }
      });

      if (rect) ctx.restore();
    }

    ctx.restore();
  }

  function drawBalloonsOnCtx(ctx, pageData, selected) {
    ctx.save();
    for (const [panelIndex, balloons] of Object.entries(pageData.text)) {
      const rect = pageData.frames[panelIndex];
      balloons.forEach((b, idx) => {
        if (rect) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
          ctx.clip();
        }

        const fontSize = 18;
        const baseSize = measureBalloonSize(b.text, fontSize);
        const scaleB   = b.scale || 1;
        const rx = baseSize.rx * scaleB;
        const ry = baseSize.ry * scaleB;

        const isSelected =
          selected &&
          selected.panelIndex === Number(panelIndex) &&
          selected.balloonIndex === idx;

        ctx.beginPath();
        ctx.ellipse(b.x, b.y, rx, ry, 0, 0, Math.PI * 2);
        ctx.fillStyle = isSelected
          ? "rgba(254,249,195,0.98)"
          : "rgba(255,255,255,0.97)";
        ctx.fill();
        ctx.strokeStyle = "#111827";
        ctx.lineWidth = isSelected ? 2.5 : 2;
        ctx.stroke();

        drawBalloonTail(ctx, b, rx, ry);

        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.scale(scaleB, scaleB);
        drawVerticalBalloonText(ctx, b.text, 0, 0);
        ctx.restore();

        if (rect) ctx.restore();
      });
    }
    ctx.restore();
  }

  function drawActivePanelOverlay(ctx, pageData, panelIndex) {
    const rect = panelIndex && pageData.frames[panelIndex];
    if (!rect) return;

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    ctx.beginPath();
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
    ctx.fill("evenodd");
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = "#22c55e";
    ctx.lineWidth = 3;
    ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    ctx.restore();
  }

  function drawPageContent(ctx, pageData, options = {}) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const activeIndex = options.activePanelIndex ?? null;
    const selected = options.selectedBalloon ?? null;

    const skipPaperBase = options.skipPaperBase === true;

    if (skipPaperBase) {
      ctx.save();
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, w, h);
      ctx.restore();
    } else {
      drawPaperBase(ctx, w, h);
    }

    ctx.save();
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 3;
    Object.values(pageData.frames).forEach(rect => {
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    });
    ctx.restore();

    const roughColor = pageData.roughColor || "black";
    let roughStroke = "#111827";
    if (roughColor === "blue") roughStroke = "#60a5fa";
    if (roughColor === "gray") roughStroke = "#9ca3af";

    drawStrokeLayerOnCtx(ctx, pageData, "rough", roughStroke, 2, false);
    drawStrokeLayerOnCtx(ctx, pageData, "pen",   "#111827",   3, true);

    applyBetaFills(ctx, pageData);
    applyToneFills(ctx, pageData);

    drawBalloonsOnCtx(ctx, pageData, selected);

    if (activeIndex) {
      drawActivePanelOverlay(ctx, pageData, activeIndex);
    }
  }

  function redrawCanvas() {
    if (!drawingCanvas || !drawingCtx) return;
    const pageData = activeDrawPageData || getDrawPage(currentPage).pageData;
    const ctx = drawingCtx;
    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    drawPageContent(ctx, pageData, {
      activePanelIndex: currentPanelIndex,
      selectedBalloon: selectedBalloon,
      skipPaperBase: currentPanelMode === "beta" || currentPanelMode === "tone"
    });
  }

  // ===== ã‚ºãƒ¼ãƒ ï¼ˆãƒ›ã‚¤ãƒ¼ãƒ« + ãƒ”ãƒ³ãƒï¼‰ =====
  function onWheelZoom(evt) {
    if (!drawingCanvas) return;
    evt.preventDefault();

    const rect = drawingCanvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (drawingCanvas.width  / rect.width);
    const y = (evt.clientY - rect.top)  * (drawingCanvas.height / rect.height);

    const delta = -evt.deltaY;
    const step  = 0.1;
    const factor = delta > 0 ? (1 + step) : (1 - step);

    const pageData = activeDrawPageData;

    if (currentPanelMode === "text") {
      const idx = findBalloonAt(x, y);
      if (idx === -1 || !pageData) return;
      const arr = pageData.text[currentPanelIndex] || [];
      const b = arr[idx];
      const base = b.scale || 1;
      b.scale = Math.min(3, Math.max(0.3, base * factor));
      saveDrawPage(pageData);
      redrawCanvas();
      return;
    }

    currentZoom *= factor;
    if (currentZoom < zoomMin) currentZoom = zoomMin;
    if (currentZoom > zoomMax) currentZoom = zoomMax;
    applyCanvasZoom();
  }

  function distanceTouches(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function centerTouches(t1, t2) {
    return {
      x: (t1.clientX + t2.clientX) / 2,
      y: (t1.clientY + t2.clientY) / 2
    };
  }

  function onTouchStartZoom(evt) {
    if (evt.touches.length === 2 && drawingCanvas) {
      evt.preventDefault();
      pinchStartDistance = distanceTouches(evt.touches[0], evt.touches[1]);
      pinchStartCenter = centerTouches(evt.touches[0], evt.touches[1]);
      pinchStartPanX = panX;
      pinchStartPanY = panY;

      const pageData = activeDrawPageData;

      if (currentPanelMode === "text" && pageData) {
        const rect = drawingCanvas.getBoundingClientRect();
        const midX = pinchStartCenter.x;
        const midY = pinchStartCenter.y;
        const x = (midX - rect.left) * (drawingCanvas.width  / rect.width);
        const y = (midY - rect.top)  * (drawingCanvas.height / rect.height);

        const idx = findBalloonAt(x, y);
        if (idx !== -1) {
          const arr = pageData.text[currentPanelIndex] || [];
          pinchBalloonIndex = idx;
          pinchStartZoom = arr[idx].scale || 1;
          return;
        }
      }

      pinchBalloonIndex = null;
      pinchStartZoom = currentZoom;
    }
  }

  function onTouchMoveZoom(evt) {
    if (evt.touches.length === 2 && pinchStartDistance && drawingCanvas) {
      evt.preventDefault();
      const newDist = distanceTouches(evt.touches[0], evt.touches[1]);
      const newCenter = centerTouches(evt.touches[0], evt.touches[1]);
      const scale = newDist / pinchStartDistance;

      const pageData = activeDrawPageData;

      if (currentPanelMode === "text" && pinchBalloonIndex != null && pageData) {
        const arr = pageData.text[currentPanelIndex] || [];
        const b = arr[pinchBalloonIndex];
        if (!b) return;
        b.scale = Math.min(3, Math.max(0.3, pinchStartZoom * scale));
        saveDrawPage(pageData);
        redrawCanvas();
        return;
      }

      currentZoom = pinchStartZoom * scale;
      currentZoom = Math.min(zoomMax, Math.max(zoomMin, currentZoom));

      const dx = newCenter.x - pinchStartCenter.x;
      const dy = newCenter.y - pinchStartCenter.y;
      panX = pinchStartPanX + dx;
      panY = pinchStartPanY + dy;

      applyCanvasZoom();
    }
  }

  function onTouchEndZoom(evt) {
    if (evt.touches.length < 2) {
      pinchStartDistance = null;
      pinchStartCenter = null;
      pinchBalloonIndex = null;
    }
  }

  /* ===== ãƒ¬ãƒƒã‚¹ãƒ³ã”ã¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===== */
  function setupCanvasForLesson(lesson) {
    selectedBalloon = null;
    const panelBody = document.getElementById("sidePanelBody");
    const exportBtn = document.getElementById("sidePanelExportBtn");
    const [group] = lesson.id.split("_");
    const index = getPanelIndexFromLesson(lesson.id);
    currentPanelIndex = index;

    if (group === "frame")      currentPanelMode = "frame";
    else if (group === "rough") currentPanelMode = "rough";
    else if (group === "text")  currentPanelMode = "text";
    else if (group === "pen")   currentPanelMode = "pen";
    else if (group === "beta")  currentPanelMode = "beta";
    else if (group === "tone")  currentPanelMode = "tone";
    else                        currentPanelMode = "info";

    if (["beta", "tone", "finish"].includes(group)) {
      exportBtn.style.display = "inline-block";
    } else {
      exportBtn.style.display = "none";
    }

    if (currentPanelMode === "info") {
      panelBody.innerHTML =
        "ã“ã®å¾Œã®ä½œæ¥­ã¯æç”»ã‚½ãƒ•ãƒˆã‚„ã‚¢ãƒ—ãƒªã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚\n" +
        "ã€Œæ›¸ãå‡ºã™ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã€æ›¸ãå‡ºã—ãŸç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’ã‚½ãƒ•ãƒˆã‚„ã‚¢ãƒ—ãƒªã«èª­ã¿è¾¼ã‚“ã§ä½œæ¥­ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚";
      drawingCanvas = null;
      drawingCtx = null;
      activeDrawPageData = null;
      return;
    }

    let infoText = "";
    let toolbarHtml = "";

    if (currentPanelMode === "frame") {
      infoText = "ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã“ã®ã‚³ãƒã®æ ç·šã‚’å¼•ãã¾ã™ã€‚ï¼ˆå¾Œã®ä¸‹æããƒ»å°è©ãƒ»ãƒšãƒ³å…¥ã‚Œã®ä½œæ¥­ç¯„å›²ã«ãªã‚Šã¾ã™ï¼‰";
      toolbarHtml = `
        <div class="canvas-toolbar">
          <span>ãƒ‰ãƒ©ãƒƒã‚°ã§æ ç·šä½œæˆ / ã“ã®ã‚³ãƒã®ã¿ä¿å­˜ã•ã‚Œã¾ã™ã€‚</span>
          <button id="clearFrameBtn">ã“ã®ã‚³ãƒã®æ ã‚’æ¶ˆã™</button>
        </div>`;
    } else if (currentPanelMode === "rough") {
      infoText = `ãƒã‚¦ã‚¹ãƒ»ãƒšãƒ³ãƒ»æŒ‡ã§ä¸‹æãã‚’è¡Œã„ã¾ã™ã€‚ã€Œ${lesson.title}ã€ã®ã‚³ãƒå†…ã®ã¿æã‘ã¾ã™ã€‚`;
      toolbarHtml = `
        <div class="canvas-toolbar">
          <span>ã‚³ãƒå†…ã«ãƒ©ãƒ•ã‚’æã„ã¦ãã ã•ã„ã€‚</span>
        </div>`;
    } else if (currentPanelMode === "text") {
      infoText = `å³ã‚¯ãƒªãƒƒã‚¯ã§å¹ãå‡ºã—ã¨å°è©ã‚’è¿½åŠ ã—ã¾ã™ã€‚å·¦ãƒ‰ãƒ©ãƒƒã‚°ã§å¹ãå‡ºã—ã‚’ç§»å‹•ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§æ‹¡å¤§ç¸®å°ã€‚`;
      toolbarHtml = `
        <div class="canvas-toolbar">
          <span>ã“ã®ã‚³ãƒå†…ã ã‘ç·¨é›†ã•ã‚Œã¾ã™ã€‚ï¼ˆ/ ã‚„ ï½œ ã‚’å…¥ã‚Œã‚‹ã¨ç°¡æ˜“æ”¹è¡Œï¼‰</span>
          <button id="tailToggleBtn">å°¾ã‚’åè»¢ã™ã‚‹</button>
          <button id="editBalloonTextBtn">å°è©ä¿®æ­£</button>
        </div>`;
    } else if (currentPanelMode === "pen") {
      infoText = `ä¸‹æãã‚’å…ƒã«ãƒšãƒ³å…¥ã‚Œã—ã¾ã™ã€‚ãƒ©ãƒ•è‰²ã‚’å¤‰æ›´ã—ãŸã‚Šã€ä¸è¦ã«ãªã£ãŸã‚‰å‰Šé™¤ã§ãã¾ã™ã€‚`;
      toolbarHtml = `
        <div class="canvas-toolbar">
          <button id="draftBlueBtn">ä¸‹æãã‚’æ°´è‰²ã«ã™ã‚‹</button>
          <button id="draftGrayBtn">ä¸‹æãã‚’ã‚°ãƒ¬ãƒ¼ã«ã™ã‚‹</button>
          <button id="draftDeleteBtn">ä¸‹æãã‚’å‰Šé™¤ã™ã‚‹</button>
        </div>`;
    } else if (currentPanelMode === "beta") {
      infoText = `ãƒšãƒ³å…¥ã‚Œæ¸ˆã¿ã®ç·šã§å›²ã£ãŸéƒ¨åˆ†ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ™ã‚¿å¡—ã‚Šã‚’è¡Œã„ã¾ã™ã€‚`;
      toolbarHtml = `
        <div class="canvas-toolbar">
          <span>ã‚³ãƒå†…ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨é»’ã§å¡—ã‚Šã¤ã¶ã—ã¾ã™ã€‚</span>
          <button id="betaUndoBtn">å–ã‚Šæ¶ˆã—</button>
        </div>`;
    } else if (currentPanelMode === "tone") {
      infoText = `ãƒšãƒ³å…¥ã‚Œæ¸ˆã¿ã®ç·šã§å›²ã£ãŸéƒ¨åˆ†ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒˆãƒ¼ãƒ³ï¼ˆç¶²ç‚¹ï¼‰ã‚’è²¼ã‚Šã¾ã™ã€‚`;
      toolbarHtml = `
        <div class="canvas-toolbar">
          <span>ã‚³ãƒå†…ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ç¶²ç‚¹ï¼ˆ45Â°ãƒ»20ï¼…ç¨‹åº¦ï¼‰ã§å¡—ã‚Šã¤ã¶ã—ã¾ã™ã€‚</span>
          <button id="toneUndoBtn">å–ã‚Šæ¶ˆã—</button>
        </div>`;
    }

    panelBody.innerHTML = `
      <div style="margin-bottom:0; font-size:13px;">${infoText}</div>
      ${toolbarHtml}
      <div class="canvas-wrapper">
        <canvas id="pageCanvas" width="${EDIT_CANVAS_WIDTH}" height="${EDIT_CANVAS_HEIGHT}"></canvas>
      </div>
    `;

    drawingCanvas = document.getElementById("pageCanvas");
    drawingCtx = drawingCanvas.getContext("2d");
    clearCanvasListeners(drawingCanvas);

    const { pageData } = getDrawPage(currentPage);
    if (!pageData.beta) pageData.beta = {};
    if (!pageData.tone) pageData.tone = {};
    activeDrawPageData = pageData;

    resetZoomForMode();
    redrawCanvas();

    if (currentPanelMode === "frame") {
      const clearBtn = document.getElementById("clearFrameBtn");
      if (clearBtn) {
        clearBtn.onclick = () => {
          delete pageData.frames[currentPanelIndex];
          const all = loadDrawAll();
          all[String(currentPage)] = pageData;
          saveDrawAll(all);
          redrawCanvas();
        };
      }

    } else if (currentPanelMode === "pen") {
      const blueBtn = document.getElementById("draftBlueBtn");
      const grayBtn = document.getElementById("draftGrayBtn");
      const delBtn  = document.getElementById("draftDeleteBtn");

      if (blueBtn) {
        blueBtn.onclick = () => {
          pageData.roughColor = "blue";
          saveDrawPage(pageData);
          redrawCanvas();
        };
      }
      if (grayBtn) {
        grayBtn.onclick = () => {
          pageData.roughColor = "gray";
          saveDrawPage(pageData);
          redrawCanvas();
        };
      }
      if (delBtn) {
        delBtn.onclick = () => {
          pageData.rough = {};
          saveDrawPage(pageData);
          redrawCanvas();
        };
      }

    } else if (currentPanelMode === "text") {
      const tailBtn = document.getElementById("tailToggleBtn");
      const editBtn = document.getElementById("editBalloonTextBtn");

      if (tailBtn) {
        tailBtn.onclick = () => {
          if (!selectedBalloon || selectedBalloon.panelIndex !== currentPanelIndex) return;
          const arr = pageData.text[currentPanelIndex] || [];
          const b = arr[selectedBalloon.balloonIndex];
          if (!b) return;
          b.tailSide = (b.tailSide === "right") ? "left" : "right";
          saveDrawPage(pageData);
          selectedBalloon = null;
          redrawCanvas();
        };
      }

      if (editBtn) {
        editBtn.onclick = () => {
          if (!selectedBalloon || selectedBalloon.panelIndex !== currentPanelIndex) return;
          const arr = pageData.text[currentPanelIndex] || [];
          const b = arr[selectedBalloon.balloonIndex];
          if (!b) return;
          const newText = window.prompt(
            "å°è©ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ï¼ˆ/ ã‚„ ï½œ ã§ç°¡æ˜“æ”¹è¡Œï¼‰",
            b.text || ""
          );
          if (newText == null) return;
          b.text = newText;
          saveDrawPage(pageData);
          selectedBalloon = null;
          redrawCanvas();
        };
      }
    } else if (currentPanelMode === "beta") {
      const undoBtn = document.getElementById("betaUndoBtn");
      if (undoBtn) {
        undoBtn.onclick = () => {
          const list = pageData.beta[currentPanelIndex] || [];
          if (list.length > 0) {
            list.pop();
            pageData.beta[currentPanelIndex] = list;
            saveDrawPage(pageData);
            redrawCanvas();
          }
        };
      }
    } else if (currentPanelMode === "tone") {
      const undoBtn = document.getElementById("toneUndoBtn");
      if (undoBtn) {
        undoBtn.onclick = () => {
          const list = pageData.tone[currentPanelIndex] || [];
          if (list.length > 0) {
            list.pop();
            pageData.tone[currentPanelIndex] = list;
            saveDrawPage(pageData);
            redrawCanvas();
          }
        };
      }
    }

    let frameStart = null;

    function handleDown(evt) {
      if (evt.touches && evt.touches.length > 1) return;
      evt.preventDefault();
      const { x, y } = getCanvasPos(evt);

      if (currentPanelMode === "frame") {
        frameStart = { x, y };
      } else if (currentPanelMode === "rough" || currentPanelMode === "pen") {
        isDrawing = true;
        lastX = x;
        lastY = y;

        const layer = currentPanelMode === "rough" ? pageData.rough : pageData.pen;
        if (!layer[currentPanelIndex]) layer[currentPanelIndex] = [];

        let w;
        if (currentPanelMode === "pen") w = getStrokeWidth(evt, "pen");
        else w = 2.0;

        layer[currentPanelIndex].push({ points: [{ x, y, w }] });
      }
    }

    function handleMove(evt) {
      if (!drawingCanvas) return;

      if (currentPanelMode === "frame") {
        if (!frameStart) return;
        const { x, y } = getCanvasPos(evt);
        redrawCanvas();
        drawingCtx.save();
        drawingCtx.strokeStyle = "#22c55e";
        drawingCtx.lineWidth = 2;
        drawingCtx.setLineDash([8, 4]);
        drawingCtx.strokeRect(frameStart.x, frameStart.y, x - frameStart.x, y - frameStart.y);
        drawingCtx.restore();
      } else if ((currentPanelMode === "rough" || currentPanelMode === "pen") && isDrawing) {
        const pos = getCanvasPos(evt);
        let x = pos.x;
        let y = pos.y;

        const dx = x - lastX;
        const dy = y - lastY;
        if (dx * dx + dy * dy < 4) return;

        const rect = pageData.frames[currentPanelIndex];
        if (rect && !pointInRect(x, y, rect)) {
          lastX = x; lastY = y;
          return;
        }

        const layer = currentPanelMode === "rough" ? pageData.rough : pageData.pen;
        const paths = layer[currentPanelIndex];
        if (!paths || paths.length === 0) return;
        const path = paths[paths.length - 1];

        let w;
        if (currentPanelMode === "pen") {
          w = getStrokeWidth(evt, "pen");
        } else {
          w = 2.0;
        }

        path.points.push({ x, y, w });
        lastX = x; lastY = y;
        redrawCanvas();
      }
    }

    function handleUp(evt) {
      if (currentPanelMode === "frame") {
        if (frameStart) {
          const { x, y } = getCanvasPos(evt);
          const rect = normalizeRect(frameStart.x, frameStart.y, x, y);
          pageData.frames[currentPanelIndex] = rect;
          saveDrawPage(pageData);
          frameStart = null;
          redrawCanvas();
        }
      } else if (currentPanelMode === "rough" || currentPanelMode === "pen") {
        if (isDrawing) {
          isDrawing = false;
          saveDrawPage(pageData);
        }
      }
    }

    function betaClick(evt) {
      evt.preventDefault();
      const { x, y } = getCanvasPos(evt);
      const rect = pageData.frames[currentPanelIndex];
      if (!rect || !pointInRect(x, y, rect)) return;

      if (!pageData.beta[currentPanelIndex]) pageData.beta[currentPanelIndex] = [];
      pageData.beta[currentPanelIndex].push({ x, y });
      saveDrawPage(pageData);
      redrawCanvas();
    }

    function toneClick(evt) {
      evt.preventDefault();
      const { x, y } = getCanvasPos(evt);
      const rect = pageData.frames[currentPanelIndex];
      if (!rect || !pointInRect(x, y, rect)) return;

      if (!pageData.tone[currentPanelIndex]) pageData.tone[currentPanelIndex] = [];
      pageData.tone[currentPanelIndex].push({ x, y });
      saveDrawPage(pageData);
      redrawCanvas();
    }

    function textMouseDown(evt) {
      evt.preventDefault();
      if (evt.touches && evt.touches.length > 1) return;

      const { x, y } = getCanvasPos(evt);
      const idx = findBalloonAt(x, y);

      const isTouch =
        evt.pointerType === "touch" ||
        (evt.touches && evt.touches.length > 0);

      if (isTouch) {
        if (evt.touches && evt.touches.length > 1) {
          return;
        }
        if (idx !== -1) {
          draggingBalloon = {
            index: idx,
            startX: x,
            startY: y,
            hasMoved: false
          };
        } else {
          selectedBalloon = null;
          redrawCanvas();
          textContextMenu(evt);
        }
        return;
      }

      if (idx !== -1) {
        draggingBalloon = {
          index: idx,
          startX: x,
          startY: y,
          hasMoved: false
        };
      } else {
        selectedBalloon = null;
        redrawCanvas();
      }
    }

    function textMouseMove(evt) {
      if (!draggingBalloon) return;
      evt.preventDefault();
      const { x, y } = getCanvasPos(evt);

      const dx = x - draggingBalloon.startX;
      const dy = y - draggingBalloon.startY;
      const dist2 = dx * dx + dy * dy;

      if (dist2 > 9) {
        draggingBalloon.hasMoved = true;
      } else if (!draggingBalloon.hasMoved) {
        return;
      }

      const arr = pageData.text[currentPanelIndex] || [];
      const b = arr[draggingBalloon.index];
      if (!b) return;
      const rect = pageData.frames[currentPanelIndex];
      if (rect && !pointInRect(x, y, rect)) return;

      b.x = x;
      b.y = y;
      saveDrawPage(pageData);
      redrawCanvas();
    }

    function textMouseUp(evt) {
      if (!draggingBalloon) return;

      if (!draggingBalloon.hasMoved) {
        selectedBalloon = {
          panelIndex: currentPanelIndex,
          balloonIndex: draggingBalloon.index
        };
        redrawCanvas();
      }

      draggingBalloon = null;
    }

    function textContextMenu(evt) {
      evt.preventDefault();
      const { x, y } = getCanvasPos(evt);
      const rect = pageData.frames[currentPanelIndex];
      if (rect && !pointInRect(x, y, rect)) return;
      const text = window.prompt("å°è©ï¼ˆç¸¦æ›¸ãï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„\nï¼ˆ/ ã‚„ ï½œ ã§ç°¡æ˜“æ”¹è¡Œï¼‰", "");
      if (!text) return;
      if (!pageData.text[currentPanelIndex]) pageData.text[currentPanelIndex] = [];
      pageData.text[currentPanelIndex].push({
        x,
        y,
        text,
        scale: 1,
        tailSide: "left"
      });
      selectedBalloon = null;
      saveDrawPage(pageData);
      redrawCanvas();
    }

    if (currentPanelMode === "text") {
      drawingCanvas.onmousedown   = textMouseDown;
      drawingCanvas.onmousemove   = textMouseMove;
      drawingCanvas.onmouseup     = textMouseUp;
      drawingCanvas.onmouseleave  = textMouseUp;
      drawingCanvas.oncontextmenu = textContextMenu;

      drawingCanvas.ontouchstart  = textMouseDown;
      drawingCanvas.ontouchmove   = textMouseMove;
      drawingCanvas.ontouchend    = textMouseUp;
    } else if (currentPanelMode === "beta") {
      drawingCanvas.onmousedown   = betaClick;
      drawingCanvas.ontouchstart  = betaClick;
      drawingCanvas.onmousemove   = null;
      drawingCanvas.onmouseup     = null;
      drawingCanvas.onmouseleave  = null;
      drawingCanvas.oncontextmenu = evt => evt.preventDefault();
    } else if (currentPanelMode === "tone") {
      drawingCanvas.onmousedown   = toneClick;
      drawingCanvas.ontouchstart  = toneClick;
      drawingCanvas.onmousemove   = null;
      drawingCanvas.onmouseup     = null;
      drawingCanvas.onmouseleave  = null;
      drawingCanvas.oncontextmenu = evt => evt.preventDefault();
    } else {
      drawingCanvas.onmousedown   = handleDown;
      drawingCanvas.onmousemove   = handleMove;
      drawingCanvas.onmouseup     = handleUp;
      drawingCanvas.onmouseleave  = handleUp;

      drawingCanvas.ontouchstart  = handleDown;
      drawingCanvas.ontouchmove   = handleMove;
      drawingCanvas.ontouchend    = handleUp;
    }

    drawingCanvas.addEventListener("wheel", onWheelZoom, { passive: false });
    drawingCanvas.addEventListener("touchstart", onTouchStartZoom, { passive: false });
    drawingCanvas.addEventListener("touchmove",  onTouchMoveZoom,  { passive: false });
    drawingCanvas.addEventListener("touchend",   onTouchEndZoom,   { passive: false });

    drawingCanvas.onpointerdown = evt => {
      if (currentPanelMode !== "pen") return;
      if (evt.button === 1) {
        isPanning = true;
        panStartClientX = evt.clientX;
        panStartClientY = evt.clientY;
        panStartX = panX;
        panStartY = panY;
      }
    };

    drawingCanvas.onpointermove = evt => {
      if (currentPanelMode !== "pen") return;
      if (isPanning) {
        const dx = evt.clientX - panStartClientX;
        const dy = evt.clientY - panStartClientY;
        panX = panStartX + dx;
        panY = panStartY + dy;
        applyCanvasZoom();
      }
    };

    drawingCanvas.onpointerup = evt => {
      if (currentPanelMode !== "pen") return;
      isPanning = false;
    };

    drawingCanvas.onpointercancel = drawingCanvas.onpointerup;
  }

  /* ===== ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ«é–‹é–‰ ===== */
  function openLessonPanel(lessonId) {
    const { progress } = loadPageProgress(currentPage);
    const lesson = LESSONS.find(l => l.id === lessonId);
    if (!lesson) return;

    const panel   = document.getElementById("sidePanel");
    const titleEl = document.getElementById("sidePanelTitle");
    if (!panel || !titleEl) return;

    titleEl.textContent = lesson.title;

    pendingLessonId = lessonId;
    setupCanvasForLesson(lesson);
    panel.classList.add("open");
  }

  function closeLessonPanel() {
    const panel = document.getElementById("sidePanel");
    if (panel) panel.classList.remove("open");
    pendingLessonId = null;
    drawingCanvas = null;
    drawingCtx = null;
    draggingBalloon = null;
    activeDrawPageData = null;
  }

  /* ===== ãƒãƒƒãƒ—æç”» ===== */
  function renderMap(progress) {
    const mapEl = document.getElementById("map");
    mapEl.innerHTML = "";

    const perRow = getPerRow();
    const positions = computeGridPositions(LESSONS.length, perRow);

    const nextLesson = getNextIncompleteLesson(progress);
    const nextId = nextLesson ? nextLesson.id : null;

    LESSONS.forEach((lesson, index) => {
      const completed = isLessonCompleted(lesson, progress);
      const isNext    = nextId && lesson.id === nextId;
      const isFuture  = !completed && !isNext;

      const pos = positions[index];

      const node = document.createElement("div");
      node.className = "node";
      node.dataset.lessonId = lesson.id;
      node.style.left = pos.x + "%";
      node.style.top  = pos.y + "%";

      if (completed) {
        node.classList.add("completed");
      } else if (isNext) {
        node.classList.add("unlocked");
      } else if (isFuture) {
        node.classList.add("locked");
      }

      if (isNext) {
        node.classList.add("next-node");
      }

      const circle = document.createElement("div");
      circle.className = "node-circle";
      circle.textContent = index + 1;

      const title = document.createElement("div");
      title.className = "node-title";
      title.textContent = lesson.title;

      const progressText = document.createElement("div");
      progressText.className = "node-progress";
      if (completed) {
        progressText.textContent = "ã‚¯ãƒªã‚¢æ¸ˆã¿";
      } else if (isNext) {
        progressText.textContent = "ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚€";
      } else {
        progressText.textContent = "ãƒ­ãƒƒã‚¯ä¸­";
      }

      node.appendChild(circle);
      node.appendChild(title);
      node.appendChild(progressText);

      node.addEventListener("click", () => openLessonPanel(lesson.id));

      mapEl.appendChild(node);
    });

    requestAnimationFrame(drawLinesFromDom);
  }

  function drawLinesFromDom() {
    const mapEl = document.getElementById("map");
    if (!mapEl) return;

    const oldSvg = mapEl.querySelector(".map-lines");
    if (oldSvg) oldSvg.remove();

    const nodes = Array.from(mapEl.querySelectorAll(".node"));
    if (nodes.length < 2) return;

    const mapRect = mapEl.getBoundingClientRect();
    const centers = nodes.map(node => {
      const r = node.getBoundingClientRect();
      const cx = (r.left + r.right) / 2 - mapRect.left;
      const cy = (r.top + r.bottom) / 2 - mapRect.top;
      return { x: cx, y: cy };
    });

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "map-lines");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");
    svg.setAttribute("viewBox", `0 0 ${mapRect.width} ${mapRect.height}`);
    svg.setAttribute("preserveAspectRatio", "none");

    for (let i = 0; i < centers.length - 1; i++) {
      const p1 = centers[i];
      const p2 = centers[i + 1];
      const path = document.createElementNS(svgNS, "path");
      const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
      path.setAttribute("d", d);
      path.setAttribute("class", "map-line");
      svg.appendChild(path);
    }

    mapEl.insertBefore(svg, mapEl.firstChild);
  }

  function renderAll() {
    const { data, progress } = loadPageProgress(currentPage);
    renderMap(progress);
    updateStreakDisplay();
    updatePageLabel(data);
    updateNextTaskDisplay(progress);
  }

  /* ===== æ›¸ãå‡ºã— ===== */
  function exportCurrentPageImage() {
    const { pageData } = getDrawPage(currentPage);

    const work = document.createElement("canvas");
    work.width = EDIT_CANVAS_WIDTH;
    work.height = EDIT_CANVAS_HEIGHT;
    const wctx = work.getContext("2d");

    drawPageContent(wctx, pageData, {
      activePanelIndex: null,
      selectedBalloon: null
    });

    const off = document.createElement("canvas");
    off.width = EXPORT_WIDTH;
    off.height = EXPORT_HEIGHT;
    const ctx = off.getContext("2d");

    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, off.width, off.height);

    const scale = Math.min(
      off.width / work.width,
      off.height / work.height
    );
    const drawW = work.width * scale;
    const drawH = work.height * scale;
    const offsetX = (off.width - drawW) / 2;
    const offsetY = (off.height - drawH) / 2;

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(work, offsetX, offsetY, drawW, drawH);

    const url = off.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = `manga_page${currentPage}.png`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  /* ===== èµ·å‹• ===== */
  window.addEventListener("DOMContentLoaded", () => {
    createTonePatternData();

    renderAll();

    document.getElementById("resetProgressBtn").addEventListener("click", () => {
      if (!confirm("æœ¬å½“ã«å…¨ãƒšãƒ¼ã‚¸ã®é€²æ—ãƒ»é€£ç¶šæ—¥æ•°ãƒ»æ ç·šã‚„ä¸‹æããƒ»å°è©ãƒ»ãƒšãƒ³å…¥ã‚Œã‚’ã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
      resetAllPagesProgress();
      resetStreakData();
      resetAllDrawData();
      renderAll();
    });

    document.getElementById("prevPageBtn").addEventListener("click", () => {
      if (currentPage > 1) {
        currentPage--;
        renderAll();
      }
    });
    document.getElementById("nextPageBtn").addEventListener("click", () => {
      const data = loadAllProgress();
      if (currentPage < data.maxPage) {
        currentPage++;
        renderAll();
      }
    });
    document.getElementById("addPageBtn").addEventListener("click", () => {
      const data = loadAllProgress();
      const newPage = data.maxPage + 1;
      data.maxPage = newPage;
      data.pages[String(newPage)] = createInitialProgressMap();
      saveAllProgress(data);
      currentPage = newPage;
      logMessage(`${newPage}ãƒšãƒ¼ã‚¸ç›®ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚`);
      renderAll();
    });
    document.getElementById("resetPagesBtn").addEventListener("click", () => {
      if (!confirm("å…¨ãƒšãƒ¼ã‚¸ã‚’å‰Šé™¤ã—ã¦ 1ãƒšãƒ¼ã‚¸ç›®ã ã‘æ®‹ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;
      const data = loadAllProgress();
      data.maxPage = 1;
      data.pages = { "1": createInitialProgressMap() };
      saveAllProgress(data);
      currentPage = 1;
      renderAll();
      logMessage("ãƒšãƒ¼ã‚¸æ•°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚");
    });

    const closeBtn = document.getElementById("sidePanelClose");
    const doneBtn  = document.getElementById("sidePanelDoneBtn");
    const exportBtn = document.getElementById("sidePanelExportBtn");

    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        pendingLessonId = null;
        closeLessonPanel();
      });
    }
    if (doneBtn) {
      doneBtn.addEventListener("click", () => {
        if (!pendingLessonId) {
          closeLessonPanel();
          return;
        }
        const id = pendingLessonId;
        pendingLessonId = null;
        closeLessonPanel();
        advanceLesson(id);
      });
    }
    if (exportBtn) {
      exportBtn.addEventListener("click", () => {
        exportCurrentPageImage();
      });
    }

    window.addEventListener("resize", () => {
      renderAll();
    });
  });
</script>

</body>
</html>
